<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="GaoLijie&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="GaoLijie&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GaoLijie&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>GaoLijie's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GaoLijie's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/图的遍历/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/15/图的遍历/" itemprop="url">图的遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-15T12:05:20+08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-采用DFS遍历图"><a href="#1-采用DFS遍历图" class="headerlink" title="1 采用DFS遍历图"></a>1 采用DFS遍历图</h4><p>深度优先遍历采用“深度”作为关键词，沿着路径知道不能再前进的时候才后退， 后退道路径距离当前顶点最近的且还存在未访问分支的岔道口，后访问未访问的分支顶点，直到遍历完整个图。</p>
<p>具体实现的时候要注意两种概念：</p>
<p><strong>· 连通分量</strong>：无向图若两个顶点可以相互到达（可以通过一定的路径间接到达也算到达）则两个顶点连通。如果G(V, E)任意两个顶点均连通，则称为连通图。否则为非连通图。 其中极大连通子图均称为连通分量</p>
<p><strong>· 强连通分量</strong>：有向图，如果两个顶点可以各自通过一条有向路径到达另外一个顶点，则两个顶点强连通。如果图G(V, E)的任意两个顶点都强连通，则图G为强连通图；否则图G为非强连通图，且称其中的极大连通子图为连通分量。</p>
<p>我们以下为方便，将连通分量和强连通分量均称为连通块。</p>
<p>如果要遍历整个图，就需要对所有连通块分别进行遍历，DFS基本思路就是将经过的顶点设置为已访问，下次不处理此点，直到所有顶点都被标记已访问。（如果题目给出已经是连通图则只要一次DFS就可以）</p>
<p>DFS伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DFS(u) &#123;	<span class="comment">//访问顶点u</span></span><br><span class="line">	vis[u] == <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(从u出发能够到达的所有顶点v)	&#123;	<span class="comment">//枚举u可以到达的所有顶点</span></span><br><span class="line">		<span class="keyword">if</span> vis[v] == <span class="literal">false</span>	<span class="comment">//如果v未被访问</span></span><br><span class="line">			DFS(v); </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">DFSTrave(G) &#123;	<span class="comment">//遍历图G</span></span><br><span class="line">	<span class="keyword">for</span>(G的所有顶点u) &#123;</span><br><span class="line">	 	<span class="keyword">if</span> vis[u] == <span class="literal">false</span></span><br><span class="line">			DFS(u);		<span class="comment">//访问u所在的连通块 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将邻接矩阵和邻接表带入伪代码则可以得到模板：</p>
<p>两种模板都需要先初始化MAXV为最大顶点、INF为一个很大的数字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br></pre></td></tr></table></figure>
<p>以下模板要理解并且熟练背诵快速打出模板</p>
<p>①邻接矩阵版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;	<span class="comment">//设置u已经被访问</span></span><br><span class="line">	此处写对u进行一些操作;</span><br><span class="line">	<span class="comment">//下面对从u出发对u进行一些枚举操作 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;	<span class="comment">//对每个顶点v</span></span><br><span class="line">		<span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) &#123;	<span class="comment">//如果v未被访问且u可以到达v </span></span><br><span class="line">			DFS(v, depth + <span class="number">1</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[u] == <span class="literal">false</span>) &#123;</span><br><span class="line">			DFS(u, <span class="number">1</span>);	<span class="comment">//访问v和u所在的连通块 1表示初始为第一层 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②邻接表版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;	<span class="comment">//设置u已经被访问</span></span><br><span class="line">	此处写对u进行一些操作;</span><br><span class="line">	<span class="comment">//下面对从u出发对u进行一些枚举操作 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;	<span class="comment">//对每个顶点v</span></span><br><span class="line">		<span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) &#123;	<span class="comment">//如果v未被访问且u可以到达v </span></span><br><span class="line">			DFS(v, depth + <span class="number">1</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[u] == <span class="literal">false</span>) &#123;</span><br><span class="line">			DFS(u, <span class="number">1</span>);	<span class="comment">//访问v和u所在的连通块 1表示初始为第一层 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[MAXV];		<span class="comment">//图G的邻接表</span></span><br><span class="line"><span class="keyword">int</span> n;	<span class="comment">//n为顶点数 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;	<span class="comment">//如果顶点i已经被访问 则vis[i]==true 初值为false </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;</span><br><span class="line">	对u需要进行一些操作在此处写;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Adj[u].size(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = Adj[u][i];</span><br><span class="line">		<span class="keyword">if</span>(vis[v] == <span class="literal">false</span>) &#123;	<span class="comment">//如果v未被访问</span></span><br><span class="line">			DFS(v, depth + <span class="number">1</span>);	<span class="comment">//访问v 深度加1 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTrave</span><span class="params">()</span> </span>&#123;	<span class="comment">//遍历图G</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[u] == <span class="literal">false</span>) &#123;	<span class="comment">//如果u未被访问</span></span><br><span class="line">			DFS(u, <span class="number">1</span>);	<span class="comment">//访问u和v连通块 1表示为第一层 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-使用BFS实现遍历"><a href="#2-使用BFS实现遍历" class="headerlink" title="2 使用BFS实现遍历"></a>2 使用BFS实现遍历</h4><p>以广度优先遍历使得未曾加入过队列的顶点全部入队。</p>
<p>BFS的具体实现(伪代码)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BFS伪代码 </span></span><br><span class="line">BFS() &#123;	<span class="comment">//遍历u所在的连通块</span></span><br><span class="line">	<span class="built_in">queue</span> q;	<span class="comment">//定义队列q</span></span><br><span class="line">	将u入队;</span><br><span class="line">	inq[u] = <span class="literal">true</span>;		<span class="comment">//设置u已经入过队列 </span></span><br><span class="line">	<span class="keyword">while</span>(q非空) &#123;		<span class="comment">//只要队列非空</span></span><br><span class="line">		取出q的队首元素u进行访问;</span><br><span class="line">		<span class="keyword">for</span>(从u出发可达的所有顶点) &#123;	<span class="comment">//枚举从u能够直接到达的顶点v</span></span><br><span class="line">			<span class="keyword">if</span>(从u出发可达的所有顶点v) &#123;	<span class="comment">//入过v未曾加入过队列</span></span><br><span class="line">				将v入队;</span><br><span class="line">				inq[v] = <span class="literal">true</span>;		<span class="comment">//设置v已经被加入队列 </span></span><br><span class="line">			&#125;	 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BFSTrave(G) &#123;	<span class="comment">//遍历图G</span></span><br><span class="line">	<span class="keyword">for</span>(G的所有顶点u) &#123;	<span class="comment">//枚举G的所有顶点u</span></span><br><span class="line">		<span class="keyword">if</span>(inq[u] == <span class="literal">false</span>) &#123;	<span class="comment">//如果u未曾入队</span></span><br><span class="line">			BFS(u); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下分别用邻接矩阵和邻接表实现BFS遍历图，建议将下面的代码都理解并且能够熟练写出来：</p>
<p>①邻接矩阵版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵版</span></span><br><span class="line"><span class="keyword">int</span> n, G[MAXV][MAXV];		<span class="comment">//n为顶点数 MAXV为 </span></span><br><span class="line"><span class="keyword">bool</span> inq[MAXV] = &#123;<span class="literal">false</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;	<span class="comment">//遍历u所在的连通块</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;	<span class="comment">//定义初始u入队 </span></span><br><span class="line">	q.push(u); 		<span class="comment">//将初始点u入队</span></span><br><span class="line">	inq[u] = <span class="literal">true</span>;	<span class="comment">//设置u已经被加入过队列</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;		<span class="comment">//只要队列非空 </span></span><br><span class="line">		<span class="keyword">int</span> u = q.front();	<span class="comment">//取出队首元素</span></span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">			<span class="comment">//如果u的邻接点v未曾加入过队列</span></span><br><span class="line">			<span class="keyword">if</span>(inq[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != INF) &#123;</span><br><span class="line">				q.push(v);	<span class="comment">//将v加入队列</span></span><br><span class="line">				inq[v] = <span class="literal">true</span>;	<span class="comment">//标记v为已被加入过队列 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span> </span>&#123;	<span class="comment">//遍历图G</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(inq[u] == <span class="literal">false</span>) &#123;	<span class="comment">//如果u未曾入过队列</span></span><br><span class="line">			BFS(q);		<span class="comment">//遍历u所在的连通块 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②邻接表版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表版</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[MAXV];		<span class="comment">//图G Adj[u]存放从顶点u出发可以到达的所有顶点 </span></span><br><span class="line"><span class="keyword">int</span> n;	<span class="comment">//n为顶点数， MAXV为最大顶点数 </span></span><br><span class="line"><span class="keyword">bool</span> inq[MAXV] = &#123;<span class="literal">false</span>&#125;;	<span class="comment">//若顶点i曾经入过队列 则inq[i] == true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;	<span class="comment">//遍历单个连通块</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;	<span class="comment">//定义队列q</span></span><br><span class="line">	q.push(u);		<span class="comment">//将初始点u </span></span><br><span class="line">	inq[u] = =<span class="literal">true</span>;	<span class="comment">//设置u已经加入过队列</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;		<span class="comment">//只要队列非空</span></span><br><span class="line">		<span class="keyword">int</span> u = q.front();	<span class="comment">//取出队首元素</span></span><br><span class="line">		q.pop();	<span class="comment">//将队首元素出队</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Adj[u].size(); i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = Adj[u][i];</span><br><span class="line">			<span class="keyword">if</span>(inq[v] == <span class="literal">false</span>) &#123;	<span class="comment">//如果v未曾入过队列、</span></span><br><span class="line">				q.push(v);	<span class="comment">//将v入队 </span></span><br><span class="line">				inq[v] = <span class="literal">true</span>;	<span class="comment">//标记v为已经如过队列 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTrave</span><span class="params">()</span> </span>&#123;	<span class="comment">//遍历图G</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;	<span class="comment">//枚举所有顶点</span></span><br><span class="line">		<span class="keyword">if</span>(inq[u] == <span class="literal">false</span>) &#123;	<span class="comment">//如果u未曾加入过队列 </span></span><br><span class="line">			BFS(q);		<span class="comment">//遍历u所在的连通块 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS一样，给定BFS起点，需要输出该连通块内所有其他顶点的层号，这时只需要使用结构体。在结构体中增加一个层号的标记。并且在遍历过程中加入层数考虑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;	<span class="comment">//顶点编号</span></span><br><span class="line">	<span class="keyword">int</span> layer;	<span class="comment">//顶点层号 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时vector中存放的为node 而不是int</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br><span class="line"><span class="comment">//接下来要考虑层号的传递关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;	<span class="comment">//s为起始顶点编号</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;Node&gt; q;	<span class="comment">//BFS队列</span></span><br><span class="line">	Node start;		<span class="comment">//起始顶点</span></span><br><span class="line">	start.layer = <span class="number">0</span>;	<span class="comment">//起始顶点层序号为0</span></span><br><span class="line">	q.push(start);	<span class="comment">//将起始顶点压入队列</span></span><br><span class="line">	inq[start.v] = <span class="literal">true</span>;	<span class="comment">//标记起始顶点的编号已经设置为加入过队列</span></span><br><span class="line">	<span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">		Node topNode = q.front();	<span class="comment">//取出队首顶点</span></span><br><span class="line">		q.pop();	<span class="comment">//队首顶点出队</span></span><br><span class="line">		<span class="keyword">int</span> u = topNode.v;		<span class="comment">//队首顶点的编号</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Adj[u].size(); i++) &#123;</span><br><span class="line">			Node next = Adj[u][i];	<span class="comment">//从u出发能够达到的顶点next</span></span><br><span class="line">			next.layer = topNode.layer + <span class="number">1</span>;		<span class="comment">//next层号等于当前顶点层号+1</span></span><br><span class="line">			<span class="comment">//如果next的编号未被加入过队列</span></span><br><span class="line">			<span class="keyword">if</span>(inq[next.v] == <span class="literal">false</span>) &#123;</span><br><span class="line">				q.push(next);	<span class="comment">//将next入队</span></span><br><span class="line">				inq[next.v] = <span class="literal">true</span>;		<span class="comment">//next的编号设置为已经被加入过队列 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/图/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/15/图/" itemprop="url">图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-15T11:47:37+08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-图定义相关术语"><a href="#1-图定义相关术语" class="headerlink" title="1 图定义相关术语"></a>1 图定义相关术语</h4><p>图可以分为有向图和无向图， 有向图为所有边是有方向的，确定顶点到顶点的指向，无向图所有边都是双向的，无向边所有边为双向的。</p>
<p>顶点的度，指和该顶点相连的边的条数。对有向图，顶点的出边条数为出度，顶点的入边成为顶点的入度。</p>
<p>顶点和边均可以有量化的属性，称为权值，顶点权值为点权边权值为边权。</p>
<h4 id="2-图的存储"><a href="#2-图的存储" class="headerlink" title="2 图的存储"></a>2 图的存储</h4><h4 id="2-1-邻接矩阵"><a href="#2-1-邻接矩阵" class="headerlink" title="2.1 邻接矩阵"></a>2.1 邻接矩阵</h4><p>使用一个二维数组G[][] 来表示边的情况(可用0 1)代表边的存在情况，如果是有向图则矩阵值可以设置为边权，不存在的边可以设边权为0 、 -1 、或者为一个很大的数字。</p>
<p>缺点是对稀疏矩阵可能太大了。</p>
<h4 id="2-2-邻接表"><a href="#2-2-邻接表" class="headerlink" title="2.2 邻接表"></a>2.2 邻接表</h4><p>图G(V, E)顶点编号为0, 1, … , N-1每个顶点都可能有若干条出边，如果把同一个顶点的所有出边放在一个列表中，那么N个顶点就会有N个列表(无出边就对应空表)， N个列表成为领接表，记为Adj[N]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[N];</span><br><span class="line"></span><br><span class="line">Adj[<span class="number">1</span>].push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;	<span class="comment">//边的终点编号 </span></span><br><span class="line">	<span class="keyword">int</span> w;	<span class="comment">//边权 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//临时变量 temp.v = 3 temp.w = 4 然后把temp加入Adj[1]中</span></span><br><span class="line">Node temp;</span><br><span class="line">temp.v = <span class="number">3</span>;</span><br><span class="line">temp.w = <span class="number">4</span>;</span><br><span class="line">Adj[i].push_back(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以在结构体中定义构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v, w;</span><br><span class="line">	Node(int_v, int_w) : v(_v), w(_w) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样可以不定义临时变量实现加边权</span></span><br><span class="line">Adj[<span class="number">1</span>].push_back(Node(<span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p>顶点个数在1000个以上要用邻接表。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/14/哈夫曼树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/14/哈夫曼树/" itemprop="url">哈夫曼树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-14T22:04:14+08:00">
                2020-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/14/堆/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/14/堆/" itemprop="url">堆</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-14T20:32:34+08:00">
                2020-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-堆的定义与基本操作"><a href="#1-堆的定义与基本操作" class="headerlink" title="1 堆的定义与基本操作"></a>1 堆的定义与基本操作</h4><p>堆是一棵<strong>完全二叉树</strong>，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。</p>
<p><strong>大顶堆</strong>：每个结点都大于等于的孩子结点的最大值。</p>
<p><strong>小顶堆：</strong>每个结点都小于等于孩子结点的值。</p>
<p>建堆的方法比较好的方法是用数组存储完全二叉树。结点就按照层序存储于数组中，其中第一个结点将存储于数组中的1号位，并且数组i位表示的结点的左孩子就是2i号位，右孩子则是(2i+1)号位。于是定义数组为如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//heap 为堆 n为元素个数</span></span><br><span class="line"><span class="keyword">int</span> heap[maxn], n = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h5 id="1-1堆调整-downAdjust"><a href="#1-1堆调整-downAdjust" class="headerlink" title="1.1堆调整 downAdjust"></a>1.1堆调整 downAdjust</h5><p>堆调整的过程的为，每次调整都是把结点从上往下的调整。针对这种向下调整，调整方法是这样的：当前为结点V</p>
<p>①总是将当前结点V与它的左右孩子比较(如果有的话)</p>
<p>②假如孩子中存在一个权值比V的权值大的结点，就将其中权值最大的那个孩子结点与结点V交换。</p>
<p>③交换以后再继续将结点V和孩子比较，直到结点V的权值小或是结点V不存在孩子结点。</p>
<p>于是得到如下调整的代码，显然<strong>时间复杂度为O(logn)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对heap数组在[low, high]范围进行向下调整</span></span><br><span class="line"><span class="comment">//其中low为欲调整结点的数组下标，high一般为堆的最后一个元素的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = low, j = i * <span class="number">2</span>;	<span class="comment">//i为欲调整结点 j为其左孩子</span></span><br><span class="line">	<span class="keyword">while</span>(j &lt;= high) &#123;	<span class="comment">//存在孩子结点</span></span><br><span class="line">		<span class="comment">//如果右孩子存在 且右孩子的值大于左孩子</span></span><br><span class="line">		<span class="keyword">if</span>(j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">			j = j + <span class="number">1</span>;		<span class="comment">//让j存储右孩子下标 使得j为最大结点的下标 </span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//如果孩子中最大的权值比欲调整结点i大</span></span><br><span class="line">		<span class="keyword">if</span>(heap[j] &gt; heap[i]) &#123;</span><br><span class="line">			swap(heap[j], heap[i]);		<span class="comment">//交换最大权值的孩子与欲调整结点i</span></span><br><span class="line">			i = j;	<span class="comment">//保持i为欲调整结点、j为i的左孩子 </span></span><br><span class="line">			j = i * <span class="number">2</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;		<span class="comment">//孩子的权值均比欲调整结点i小 调整结束 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设序列中的元素个数为n， 由于完全二叉树的叶子结点个数为[n/2](上取整)，因此数组下标在[1,[n/2](下取整)]范围内的结点都是非叶子结点。于是可以从[n/2](下取整)号位开始倒着枚举结点，对每个遍历到的结点i进行[i, n]范围的调整。这是因为每次调整完一个结点后，当前子树中权值最大的结点就会处在根结点的位置，这样当遍历到其父亲结点时，就可以直接使用这个结果。也就是说，这种做法<strong>保证每个结点都是以其为根结点的子树中的权值最大的结点。</strong></p>
<h5 id="1-2建堆"><a href="#1-2建堆" class="headerlink" title="1.2建堆"></a>1.2建堆</h5><p>建堆的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		downAdjust(i, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要删除堆中的最大元素(也就是删除堆顶元素)，并且让其任然保持堆的结构。只需要最后一个元素覆盖堆顶元素，然后对根结点进行调整即可。</p>
<h5 id="1-3-删除堆顶元素"><a href="#1-3-删除堆顶元素" class="headerlink" title="1.3 删除堆顶元素"></a>1.3 删除堆顶元素</h5><p>如果要删除堆中的最大元素(就是删除堆顶元素)，并让其仍然保持堆的结构，那么只需要最后一个元素覆盖堆顶元素，然后对根结点进行调整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除堆顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	heap[<span class="number">1</span>] = heap[n--]; <span class="comment">//用最后一个元素覆盖堆顶元素 并让元素个数减1 </span></span><br><span class="line">	downAdjust(<span class="number">1</span>, n);	<span class="comment">//向下调整堆顶元素 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-4-添加一个元素-upAdjust"><a href="#1-4-添加一个元素-upAdjust" class="headerlink" title="1.4 添加一个元素 upAdjust"></a>1.4 添加一个元素 upAdjust</h5><p>如果想往堆里添加一个元素方法：把想要添加的元素放在数组的最后(也就是完全二叉树的最后一个结点后面)，然后进行<strong>向上调整</strong>操作。向上调整总是把欲调整结点与父亲结点比较。如果权值比父亲结点大，那么就交换与其父亲结点，这样反复比较，直到到达堆顶或者是父亲权值较大为止。向上调整的代码如下，时间复杂度为<strong>O(logn)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对heap数组在[low, high]范围进行向上调整</span></span><br><span class="line"><span class="comment">//其中low一般设置为1 high表示欲调整结点的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = high, j = i / <span class="number">2</span>;	<span class="comment">//i为欲调整结点，j为其父亲 </span></span><br><span class="line">	<span class="keyword">while</span>(j &gt;= low) &#123;	<span class="comment">//父亲在[low, high]范围内</span></span><br><span class="line">		<span class="comment">//父亲权值小于欲调整结点i的权值</span></span><br><span class="line">		<span class="keyword">if</span>(heap[j] &lt; heap[i]) &#123;</span><br><span class="line">			swap(heap[j], heap[i]);		<span class="comment">//交换父亲和欲调整结点</span></span><br><span class="line">			i = j;		<span class="comment">//保持i为欲调整结点 j为i的父亲 </span></span><br><span class="line">			j = i / <span class="number">2</span>; </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;		<span class="comment">//父亲权值比欲调整结点i的权值大 调整结束 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上很容易实现添加元素的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	heap[++n] = x;	<span class="comment">//让元素的个数加1 然后将数组末位赋值为x</span></span><br><span class="line">	upAdjust(<span class="number">1</span>, n);	<span class="comment">//向上调整新加入的结点n </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2 堆排序"></a>2 堆排序</h4><p>堆排序是指使用堆结构对一个序列进行排序。此处讨论递增排序的情况。</p>
<p>考虑一个大顶堆来说，堆顶元素是最大的，因此在建堆完毕后，堆排序的直观思路就是取出堆顶元素，然后将堆的最后一个元素替换到堆顶，再进行一次针对堆顶元素的向下调整。</p>
<p>故堆排序的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	createHeap();	<span class="comment">//建堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;	<span class="comment">//倒着枚举 直到堆中只有一个元素 </span></span><br><span class="line">		swap(heap[i], heap[<span class="number">1</span>]);		<span class="comment">//交换heap[i]与堆顶 </span></span><br><span class="line">		downAdjust(<span class="number">1</span>, i - <span class="number">1</span>);		<span class="comment">//调整堆顶 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/14/并查集/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/14/并查集/" itemprop="url">并查集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-14T17:15:09+08:00">
                2020-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-并查集的定义"><a href="#1-并查集的定义" class="headerlink" title="1 并查集的定义"></a>1 并查集的定义</h4><p>并查集是一种维护集合的数据结构，并查集取自”Union(合并)”、”Find(查找)”、”Set(集合)”这三个单词。</p>
<p>并查集支持：</p>
<p>①合并：合并两个集合</p>
<p>②查找：判断两个元素是否在同一个集合</p>
<p>并查集的实现：使用一个数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> father[N];</span><br></pre></td></tr></table></figure>
<p>father[i]表示i的父亲结点，而父亲结点自身也是集合内的元素，father[1] = 2 表示元素1的父亲结点是元素2</p>
<p>如果father[i]=i则说明元素i是该集合的根结点，但<strong>对于同一个集合只存在一个根节点，并且将其作为所属集合的标志</strong></p>
<h4 id="2-并查集的基本操作"><a href="#2-并查集的基本操作" class="headerlink" title="2 并查集的基本操作"></a>2 并查集的基本操作</h4><p>并查集需要先初始化father，再根据需要进行查找或者合并操作</p>
<h5 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h5><p>每个元素都是独立的一个集合，因此需要令所有father[i] = i</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">	father[i] = i;	<span class="comment">//令father[i]为-1也可 此处father[i]=i为例 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-查找"><a href="#2-2-查找" class="headerlink" title="2.2 查找"></a>2.2 查找</h5><p>由于规定同一个集合中只存在一个根结点，因此查找操作就是对给定的结点寻找其根结点的过程，实现方式可以是递推或者递归。思路一样均为反复查找父节点直到找到根结点。</p>
<p>递推查找代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//findFather函数返回元素x所在的集合的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x != father[x]) &#123;	<span class="comment">//如果不是根结点继续循环</span></span><br><span class="line">		x = father[x];	<span class="comment">//获得自己的父亲结点 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归查找代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x == father[x]) <span class="keyword">return</span> x;	<span class="comment">//如果找到根结点 则返回根结点编号x</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> findFather(father[x]);	<span class="comment">//否则递归判断x的父亲结点是否是根结点 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-合并"><a href="#2-3-合并" class="headerlink" title="2.3 合并"></a>2.3 合并</h5><p>合并指两个集合合并成的一个集合，题目一般给出两个元素，要求把这两个元素所在的集合合并。</p>
<p>实现原理，先判断两个元素是否属于同一个结点（看根结点是否相同），如果属于不同集合就合并，合并过程为把其中一个集合的根节点的父亲指向另外一个集合的根节点。</p>
<p>具体分两步：</p>
<p>①给定两个元素a b，判断是否在同一个集合，（使用查找函数）找到两个集合的根节点faA faB。</p>
<p>②合并两个集合，把一个集合的父亲结点指向另外一个结点，例如可以用father[faA] = faB 也可以反过来 father[faB] = faA 均可</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> faA = findFather(a);	<span class="comment">//查找a的根结点 记为faA</span></span><br><span class="line">	<span class="keyword">int</span> faB = findFather(b);	<span class="comment">//查找b的根结点 记为faB</span></span><br><span class="line">	<span class="keyword">if</span>(faA != faB) &#123;	<span class="comment">//如果不属于同一个集合则合并 </span></span><br><span class="line">		father[faA] = faB;	<span class="comment">//合并 此处为faB作为合并后的根结点 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保证了只对不同集合中的元素操作合并，自己集合内部不会操作，故不会有环，<strong>并查集产生的每一个集合都是一棵树。</strong></p>
<h4 id="3-路径压缩"><a href="#3-路径压缩" class="headerlink" title="3 路径压缩"></a>3 路径压缩</h4><p>以上的并查集查找函数是没有优化的，极端情况下为一个长的链，每次去查找根结点会十分的费时 效率很低。</p>
<p>但本质上递归找根结点，目的只有一个只是利用根结点去判断是否从属于几个集合，故可以吧操作等价替换一下，使查找根结点效率提高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为一个单链</span></span><br><span class="line">father[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">father[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">father[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">father[<span class="number">4</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>只是为了查找根结点，完全可以改造为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">father[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">father[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">father[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">father[<span class="number">4</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>对应图形”扁平化”了。</p>
<p><strong>把当前查询结点的查找路径上的所有结点的父亲结点都指向根结点。</strong>则查找的过程中不用反复的回溯递归去找父亲结点。</p>
<p>实现这种转换方法步骤：</p>
<p>①按原先的写法获得x的根结点r</p>
<p>②重新从x开始走一遍根结点的过程，把路径上经过的所有结点的父亲结点全部改为结点r（改造findFather函数）</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//由于x在下面的while会变为根结点 所以吧原先的x保存一下</span></span><br><span class="line">	<span class="keyword">int</span> a = x;</span><br><span class="line">	<span class="keyword">while</span>(x != father[x]) &#123; 	<span class="comment">//寻找根结点 </span></span><br><span class="line">		x = father[x];	</span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//到这里 x存放的是根结点 下面把路径上存放的所有father都改为根结点</span></span><br><span class="line">	<span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">		<span class="keyword">int</span> z = a;	<span class="comment">//因为a要被father[a]覆盖 所以先保存a的值 以修改father[a] </span></span><br><span class="line">		a = father[a];	<span class="comment">//a回溯父亲结点 对a的父亲结点进行判断是否修改 </span></span><br><span class="line">		father[z] = x;	<span class="comment">//将原先结点a的父亲结点修改为根结点 x </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;	<span class="comment">//返回根结点 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过递推把路径压缩了。可以把压缩后的并查集查找函数均摊为效力为O(1)的操作。</p>
<p>递归写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径压缩递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v == father[v]) <span class="keyword">return</span> v;	<span class="comment">//找到根结点</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> F = findFather(father[v]);	<span class="comment">//递归寻找father[v]的根结点</span></span><br><span class="line">		father[v] = F;</span><br><span class="line">		<span class="keyword">return</span> F; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">题目描述：数码世界的奇异世界，在数码世界有两条规定</span><br><span class="line">    ①数码宝贝A和数码宝贝B是好友，等价于数码宝贝B和数码宝贝A是好友</span><br><span class="line">    ②如果数码宝贝A和数码宝贝C是好友，而数码宝贝B和数码宝贝C也是好友，则A与B也是好友</span><br><span class="line">    问这些好友可以划分为多少个小组，满足每组中任意两个数码宝贝都是好友，且任意两组之间的数码宝贝都不是好友</span><br><span class="line">    </span><br><span class="line">输入格式：输入第一行 两个正整数 n (n&lt;=<span class="number">100</span>)和m(m&lt;=<span class="number">100</span>)分别表示数码宝贝的个数，和好友的组数，数码宝贝编号为<span class="number">1</span>~n</span><br><span class="line">    接下来m行 每行两个正整数a与b 表示数码宝贝a和b是好友</span><br><span class="line"></span><br><span class="line">输出格式：输出一个整数 表示这些数码宝贝可以分成的组数</span><br><span class="line">    </span><br><span class="line">输入例子<span class="number">1</span>：</span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">输入例子<span class="number">2</span>：</span><br><span class="line"><span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line">输出<span class="number">2</span>：</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>为并查集看是否在同一个集合中</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> father[N];		<span class="comment">//存放父亲结点</span></span><br><span class="line"><span class="keyword">bool</span> isRoot[N];		<span class="comment">//记录每个结点是否作为某个集合的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;		<span class="comment">//查找x所在集合的根结点 </span></span><br><span class="line">	<span class="keyword">int</span> a = x;</span><br><span class="line">	<span class="keyword">while</span>(x != father[x]) &#123;</span><br><span class="line">		x = father[x];</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//路径压缩（可不写）</span></span><br><span class="line">	<span class="keyword">while</span>(a != father[a]) &#123;</span><br><span class="line">		<span class="keyword">int</span> z = a;</span><br><span class="line">		a = father[a];</span><br><span class="line">		father[z] = x;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;	<span class="comment">//合并a和b所在的集合</span></span><br><span class="line">	<span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">	<span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">	<span class="keyword">if</span>(faA != faB) &#123;</span><br><span class="line">		father[faA] = faB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;	<span class="comment">//初始化father[i]为i 且flag[i]为false</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		father[i] = i;</span><br><span class="line">		isRoot[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	init(n);	<span class="comment">//要记得初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);		<span class="comment">//输入两个好友的关系</span></span><br><span class="line">		Union(a, b); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		isRoot[findFather(i)] = <span class="literal">true</span>;	<span class="comment">//i的根结点是findFather(i) </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;	<span class="comment">//记录集合数目</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		ans += isRoot[i];</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/14/平衡二叉树-AVL/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/14/平衡二叉树-AVL/" itemprop="url">平衡二叉树(AVL)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-14T11:26:36+08:00">
                2020-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-1平衡二叉树的定义"><a href="#1-1平衡二叉树的定义" class="headerlink" title="1.1平衡二叉树的定义"></a>1.1平衡二叉树的定义</h4><p>为了解决二叉查找树如果插入的顺序不合适，会导致二叉查找树变成一个单链(可以看二叉查找树文章当中的讨论)，例如按照递增序列建立二叉查找树就会导致一边倒的情况，从而无法发挥二叉树可以使得查找保持O(logn)查找的效率。故由使得二叉树的层数越小，导出了平衡二叉树。</p>
<p><strong>AVL依然是一棵二叉查找树</strong>(AVL的命名是由发现这个树的两个苏联科学家G.M.Adekse-Velskil和E.M.Landis提出的)，因此一般也称作AVL树。</p>
<p><strong>左子树和右子树的高度之差称为该结点的平衡因子</strong></p>
<p>由于需要对每个结点都要得到平衡因子，故在树的结点中加入一个height用以记录当前结点为根结点的子树的高度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v, height;	<span class="comment">//v为结点权值 height为当前子树高度</span></span><br><span class="line">	node *lchild, *rchild;	<span class="comment">//左右孩子结点地址 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新建结点写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;</span><br><span class="line">	Node-&gt;v = v;	<span class="comment">//结点权值</span></span><br><span class="line">	Node-&gt;height = <span class="number">1</span>;	<span class="comment">//结点高度初始为1</span></span><br><span class="line">	Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;	<span class="comment">//初始状态无左右孩子</span></span><br><span class="line">	<span class="keyword">return</span> Node; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取子树当前结点root所在的子树当前高度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取以root为根结点的子树当前的height </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//空结点高度为0 </span></span><br><span class="line">	<span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平衡因子的计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//左子树高度减右子树高度</span></span><br><span class="line">	<span class="keyword">return</span> getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考：为什么不直接记录结点的平衡因子而是记录高度？因为没有办法直接获得当前子树的平衡因子计算得到该结点的平衡因子，而需要借助子树的高度间接求得。显然，结点root所在子树height等于 其左子树的height与其右子树的height的较大值+1，因此可以通过如下的函数更新height：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//max(左孩子hight, 右孩子height) + 1</span></span><br><span class="line">	root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-平衡二叉树的基本操作"><a href="#2-平衡二叉树的基本操作" class="headerlink" title="2 平衡二叉树的基本操作"></a>2 平衡二叉树的基本操作</h4><p>AVL基本操作有查找、插入、建树以及删除。删除操作比较复杂，主要介绍AVL查找、插入和建立</p>
<h5 id="2-1查找操作"><a href="#2-1查找操作" class="headerlink" title="2.1查找操作"></a>2.1查找操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;	<span class="comment">//空树 查找失败 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"search faild\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data) &#123;	<span class="comment">//查找成功访问</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;data); </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;</span><br><span class="line">		search(root-&gt;lchild, x);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		search(root-&gt;rchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2插入操作"><a href="#2-2插入操作" class="headerlink" title="2.2插入操作"></a>2.2插入操作</h5><p>先介绍两种基本操作，是插入操作判定是哪种模式后要做的旋转基本操作。</p>
<p><img src="C:\Users\36987\AppData\Roaming\Typora\typora-user-images\image-20200114143911973.png" alt="image-20200114143911973"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋(left Rotation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">	node* temp = root-&gt;rchild;</span><br><span class="line">	root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">	temp-&gt;lchild = root;</span><br><span class="line">	updataHeight(root);</span><br><span class="line">	updataHeight(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样还有一个右旋</p>
<p><img src="C:\Users\36987\AppData\Roaming\Typora\typora-user-images\image-20200114144857545.png" alt="image-20200114144857545"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋(Right Rotation)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">	node* temp = root-&gt;lchild;</span><br><span class="line">	root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">	temp-&gt;rchild = root;</span><br><span class="line">	updateHeight(root);</span><br><span class="line">	updateHeight(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见左旋和右旋为一对相反的过程。</p>
<p>假定有一个平衡二叉树，插入一个结点后有可能会有结点的平衡因子的绝对值大于1，<strong>只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就会平衡</strong></p>
<p>注意平衡因子我们是左子树与右子树的高度之差，求root点平衡因子的函数所写为BF(root)</p>
<p>因此有如下的表格:</p>
<table>
<thead>
<tr>
<th style="text-align:center">树形</th>
<th style="text-align:center"></th>
<th style="text-align:center">调整方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LL</td>
<td style="text-align:center">BF(root) = 2, BF(root-&gt;lchild) = 1</td>
<td style="text-align:center">对root进行右旋</td>
</tr>
<tr>
<td style="text-align:center">LR</td>
<td style="text-align:center">BF(root) = 2, BF(root-&gt;lchild) = -1</td>
<td style="text-align:center">先对root-&gt;lchild进行左旋，再对root进行右旋</td>
</tr>
<tr>
<td style="text-align:center">RR</td>
<td style="text-align:center">BF(root) = -2, BF(root-&gt;rchild) = -1</td>
<td style="text-align:center">对root进行左旋</td>
</tr>
<tr>
<td style="text-align:center">RL</td>
<td style="text-align:center">BF(root) = -2, BF(root-&gt;rchild) = 1</td>
<td style="text-align:center">先对root-&gt;rchild进行右旋，再对root进行左旋</td>
</tr>
</tbody>
</table>
<p>插入代码的实现，AVL树的插入代码是在二叉查找树的插入代码的基础上加入平衡操作，不考虑平衡操作，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入权值为v的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;	<span class="comment">//到达空结点</span></span><br><span class="line">		root = newNode(v);</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(v &lt; roor-&gt;v) &#123;	<span class="comment">//v比根结点的权值小</span></span><br><span class="line">		insert(root-&gt;lchild, v); </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		insert(root-&gt;rchild, v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上 需要从插入结点从下向上判断结点的平衡，故在每次insert函数之后更新子树的高度，并且根据树形是LL型、LR型、RR型、RL型之一来进行平衡操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入权值为v的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;	<span class="comment">//到达空结点</span></span><br><span class="line">		root = newNode(v);</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(v &lt; root-&gt;v) &#123;	<span class="comment">//v比根结点的权值小</span></span><br><span class="line">		insert(root-&gt;lchild, v);	<span class="comment">//往左子树插入</span></span><br><span class="line">		updateHeight(root);		<span class="comment">//更新树高</span></span><br><span class="line">		<span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">2</span>) &#123;	<span class="comment">//根结点出现不平衡</span></span><br><span class="line">			<span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">1</span>) &#123;	<span class="comment">//LL型</span></span><br><span class="line">				R(root); </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">-1</span>) &#123;	<span class="comment">//LR型</span></span><br><span class="line">				L(root-&gt;lchild);</span><br><span class="line">				R(root); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;	<span class="comment">//v比根结点的权值大 </span></span><br><span class="line">		insert(root-&gt;rchild, v);	<span class="comment">//往右子树插入</span></span><br><span class="line">		updateHeight(root);		<span class="comment">//更新树高</span></span><br><span class="line">		<span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">-2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">-1</span>) &#123;	<span class="comment">//RR型</span></span><br><span class="line">				L(root); </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">1</span>) &#123;	<span class="comment">//RL型</span></span><br><span class="line">				R(root-&gt;rchild);</span><br><span class="line">				L(root); </span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-AVL树的建立"><a href="#2-3-AVL树的建立" class="headerlink" title="2.3 AVL树的建立"></a>2.3 AVL树的建立</h5><p>有了上面的基础我们AVL树的建立就是一步一步插入结点。边插入边调整树平衡。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AVL树的建立</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	node* root = <span class="literal">NULL</span>;	<span class="comment">//新建空根结点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		insert(root, data[i]);	<span class="comment">//将data[0]~data[n-1]插入AVL树中 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> root;	<span class="comment">//返回根结点 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property.</span><br><span class="line">Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</span><br><span class="line"></span><br><span class="line">Input Specification:</span><br><span class="line">Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</span><br><span class="line"></span><br><span class="line">Output Specification:</span><br><span class="line">For each test case, print the root of the resulting AVL tree in one line.</span><br><span class="line"></span><br><span class="line">Sample Input 1:</span><br><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">Sample Output 1:</span><br><span class="line">70</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">Sample Input 2:</span><br><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">Sample Output 2:</span><br><span class="line">88</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v, height;	<span class="comment">//v为结点权值, height为当前子树高度</span></span><br><span class="line">	node *lchild, *rchild;	<span class="comment">//左右孩子结点地址 </span></span><br><span class="line">&#125; *root; </span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个新结点，v为结点权值</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	node* Node = <span class="keyword">new</span> node;		<span class="comment">//申请一个node型变量的地址空间</span></span><br><span class="line">	Node-&gt;v = v;	<span class="comment">//结点权值为v</span></span><br><span class="line">	Node-&gt;height = <span class="number">1</span>;	<span class="comment">//结点初始高度为1</span></span><br><span class="line">	Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;		<span class="comment">//初始状态下没有左右孩子结点 </span></span><br><span class="line">	<span class="keyword">return</span> Node;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//空结点高度为0</span></span><br><span class="line">	<span class="keyword">return</span> root-&gt;height; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//max(左孩子结点的height, 右孩子结点的height)+1 </span></span><br><span class="line">	root-&gt;height = max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//左子树高度减去右子树高度</span></span><br><span class="line">	<span class="keyword">return</span> getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋 (Left Rotation)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">	node* temp = root-&gt;rchild;</span><br><span class="line">	root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">	temp-&gt;lchild = root;</span><br><span class="line">	updateHeight(root);		<span class="comment">//更新结合A的高度</span></span><br><span class="line">	updateHeight(temp);		<span class="comment">//更新结点B的高度</span></span><br><span class="line">	root = temp; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋(Right Rotation)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">	node* temp = root-&gt;lchild;</span><br><span class="line">	root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">	temp-&gt;rchild = root;</span><br><span class="line">	updateHeight(root);</span><br><span class="line">	updateHeight(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//插入权值为v的结点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;	<span class="comment">//到达空结点 </span></span><br><span class="line">		root = newNode(v);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(v &lt; root-&gt;v) &#123;	<span class="comment">//v比根结点权值小 </span></span><br><span class="line">		insert(root-&gt;lchild, v);	<span class="comment">//往左子树插入</span></span><br><span class="line">		updateHeight(root);		<span class="comment">//更新树高</span></span><br><span class="line">		<span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">1</span>) &#123;	<span class="comment">//LL型 </span></span><br><span class="line">				R(root);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">-1</span>) &#123;	<span class="comment">//LR型</span></span><br><span class="line">				L(root-&gt;lchild); </span><br><span class="line">				R(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;	<span class="comment">//v比根结点权值大</span></span><br><span class="line">		insert(root-&gt;rchild, v);	<span class="comment">//往右子树插入</span></span><br><span class="line">		updateHeight(root);		<span class="comment">//更新树高</span></span><br><span class="line">		<span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">-2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">-1</span>) &#123;	<span class="comment">//RR型</span></span><br><span class="line">				L(root); </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">1</span>) &#123;	<span class="comment">//RL型</span></span><br><span class="line">				R(root-&gt;rchild);</span><br><span class="line">				L(root); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//node* Create(int data[], int n) &#123;</span></span><br><span class="line"><span class="comment">//	node* root = NULL;	//新建空根结点root </span></span><br><span class="line"><span class="comment">//	for(int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//		insert(root, data[i]);	//将data[0]~data[n-1]插入AVL </span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	return root; </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, v;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">		insert(root, v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;v);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/二叉查找树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/13/二叉查找树/" itemprop="url">二叉查找树(BST)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-13T20:36:30+08:00">
                2020-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-1二叉查找树定义"><a href="#1-1二叉查找树定义" class="headerlink" title="1.1二叉查找树定义"></a>1.1二叉查找树定义</h4><p>二叉查找树（Binary Search Tree, BST）是特殊的二叉树，又称排序二叉树、二叉搜索树、二叉排序树。</p>
<p>递归定义：</p>
<p>①可为一棵空树</p>
<p>②非空则由根结点、左子树、右子树组成。左右子树均为一棵二叉查找树，且根结点、根左孩子、根右孩子大小为 <strong>左孩子&lt;=根结点&lt;=右孩子</strong></p>
<h4 id="2-二叉查找树的基本操作及其实现"><a href="#2-二叉查找树的基本操作及其实现" class="headerlink" title="2 二叉查找树的基本操作及其实现"></a>2 二叉查找树的基本操作及其实现</h4><p>基本操作包括查找、插入、建树、删除。</p>
<h5 id="2-1查找操作"><a href="#2-1查找操作" class="headerlink" title="2.1查找操作"></a>2.1查找操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//search函数查找二叉查找树中数据域为x的结点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;	<span class="comment">//空树 查找失败 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data) &#123;	<span class="comment">//查找成功 访问</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;data); </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;	<span class="comment">// 如果x比根结点的数据域小 说明x在左子树</span></span><br><span class="line">		search(root-&gt;lchild, x);	<span class="comment">//左子树搜索 </span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;	<span class="comment">//如果x比根结点的数据域大 在右子树 </span></span><br><span class="line">		search(root-&gt;rchild, x);	<span class="comment">//右子树搜索 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与一般二叉树不同 二叉查找树 因为每个节点与左右孩子的大小关系是固定的所以搜索的时候和一般的不太一样。</p>
<h5 id="2-2插入操作"><a href="#2-2插入操作" class="headerlink" title="2.2插入操作"></a>2.2插入操作</h5><p>二叉查找树查找一个点是沿着固定的路径查找的，所以需要查找的值查找成功则结点已存在，反之，查找失败则查找失败的地方是结点需要插入的地方。</p>
<p>故在查找操作的基础上，在root == NULL的时候插入新建的结点。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert 函数将在二叉树中插入一个数据域为x的新结点（注意参数root要加引用&amp;）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;	<span class="comment">//空树 说明查找失败 也即插入位置</span></span><br><span class="line">		root = newNode(x);</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x == root-&gt;data) &#123;	<span class="comment">//查找成功 说明结点已存在 直接返回</span></span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data) &#123;	<span class="comment">//如果x比根节点的数据域小 说明x需要插在左子树</span></span><br><span class="line">		insert(root-&gt;lchild, x);	<span class="comment">//往左子树搜索x </span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		insert(root-&gt;rchild, x);	<span class="comment">//往左子树搜索 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找插入位置插入结点 注意<strong>insert(node* &amp;root, int x)</strong>写法</p>
<h5 id="2-3二叉查找树的建立"><a href="#2-3二叉查找树的建立" class="headerlink" title="2.3二叉查找树的建立"></a>2.3二叉查找树的建立</h5><p>建立一个二叉查找树，先后插入n个结点的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉查找树的建立 </span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		insert(root, data[i]);	<span class="comment">//将data[0]~data[n-1] </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;	<span class="comment">//返回根节点 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一组相同的数字不同的顺序得到的二叉查找树可能不同。</p>
<h5 id="2-4二叉查找树的删除"><a href="#2-4二叉查找树的删除" class="headerlink" title="2.4二叉查找树的删除"></a>2.4二叉查找树的删除</h5><p>把二叉查找树中<strong>比结点权值小的最大结点</strong>称为该结点的<strong>前驱</strong>，把<strong>比结点权值大的最小结点</strong>称为该节点的<strong>后继</strong>。结点的前驱是该结点左子树中的最右结点(就是从左子树根结点沿着右子树rchild不断知道rchild为NULL时的结点)，而后继结点是该结点右子树的最左结点(从右子树根结点开始不断沿着lchild往下直到lchild为NULL时的结点)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找以root为根结点的树中的最大权值结点 </span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = root-&gt;rchild;	<span class="comment">//不断往右 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(root-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = root-&gt;lchild;	<span class="comment">//不断往左 直到没有左孩子 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对待删除结点，在左右子树当中找到前驱和后继结点，就有两种替换方法，目标均为保持二叉排序树的顺序。用前驱替换当前结点，或者用后继替换当前结点。</p>
<p>假设使用结点N的前驱节点替换当前N，问题转化为N的左子树中删除P（N操作就是前驱直接覆盖N），递归下去，知道递归到一个叶子节点（找到前驱）删除即可。</p>
<p>基本思路：</p>
<p>①如果当前结点root为空，说明不存在权值为给定权值x的结点直接返回。</p>
<p>②如果当前结点root的权值恰为给定的权值x找到需要删除的结点N，进入删除操作</p>
<p>  a)如果当前结点root不存在左右孩子，说明为叶子节点直接删除</p>
<p>  b)如果当前结点root存在左孩子，左子树中查找前驱(左子树最大结点)pre，让pre的数据域覆盖root， 左子树删除pre</p>
<p>  c)(若左子树为空则从右子树找后继代替)如果当前结点root存在右孩子，那么在右子树中寻找结点后继next,让next的数据覆盖root接着在右子树中删除结点next</p>
<p><strong>这里的优先级可以改变 具体可以看代码实现部分</strong></p>
<p>③如果当前结点root的权值大于给定的权值x，则在左子树中递归删除权值为x的结点</p>
<p>④如果当前结点root 的权值小于给定的权值x则在右子树中递归删除权值为x的结点</p>
<p>实现代码(如果需要删除叶子结点的时候释放空间)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除以root为根结点的树权值为x的结点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span> </span>&#123;	<span class="comment">//此处会修改root所在结点 故node* &amp;root使用引用 而不是使用副部访问 </span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;	<span class="comment">//不存在权值为x的结点</span></span><br><span class="line">	<span class="keyword">if</span>(root-&gt;data == x) &#123;	<span class="comment">//找到目标删除的结点位置 </span></span><br><span class="line">		<span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;	<span class="comment">//叶子结点直接删除 </span></span><br><span class="line">			root ==  <span class="literal">NULL</span>;	<span class="comment">//吧root的地址设置为NULL 父结点就引用不到了 </span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>) &#123;	<span class="comment">//左子树不为空  </span></span><br><span class="line">			node* pre = findMax(root-&gt;lchild);</span><br><span class="line">			root-&gt;data = pre-&gt;data;</span><br><span class="line">			deleteNode(root-&gt;lchild, pre-&gt;data); </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;	<span class="comment">//左子树为空 而右子树不为空 </span></span><br><span class="line">			node* next = findMin(root-&gt;rchild);	<span class="comment">//找root后继覆盖root</span></span><br><span class="line">			root-&gt;data = next-&gt;data;	<span class="comment">//用前驱覆盖root </span></span><br><span class="line">			deleteNode(root-&gt;rchild, next-&gt;data);	<span class="comment">//右子树中删除结点next </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;data &gt; x) &#123;</span><br><span class="line">		deleteNode(root-&gt;lchild, x);	<span class="comment">//在左子树中删除x </span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		deleteNode(root-&gt;rchild, x);	<span class="comment">//在右子树中删除x </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可以优化，如在找到欲删除的结点root的后继结点next，不用继续递归 直接删除该后继就可以。</p>
<p>但要注意一点。总是优先删除前驱或者后继结点容易导致树的左右子树高度极度不平衡，使得二叉查找树变为一条链，解决方法有两个：1.交替删除前驱或者后继 2.或者记录子树高度，总是优先在高度较高的一棵子树中删除结点</p>
<h5 id="3-二叉查找树的性质"><a href="#3-二叉查找树的性质" class="headerlink" title="3 二叉查找树的性质"></a>3 二叉查找树的性质</h5><p><strong>对二叉查找树的中序遍历，遍历结果为有序的</strong></p>
<p>如果合理调整二叉查找树的形态，使得树上的每个结点都尽量有两个子结点，这样二叉查找树高度很低，如果变为平衡树就变为平衡二叉树AVL。AVL是一种专用名词 默认为一棵平衡的二叉查找树。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/链表模板/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/10/链表模板/" itemprop="url">链表模板</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-10T20:28:04+08:00">
                2020-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>静态链表解决相对复杂题目的模板，一般结点数据都不会太大100010以内都可以，所以使用静态链表即可。</p>
<p>①定义静态链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> address;	<span class="comment">//结点地址</span></span><br><span class="line">	<span class="keyword">typename</span> data;	<span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">int</span> next;	<span class="comment">//指针域</span></span><br><span class="line">	xxx; 	<span class="comment">//结点的某个性质 要依据不同题目定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上对结点地址、数据域、指针域定义，留下xxx适应不同题目(例如可以设置为结点是否为某条链表上的结点 bool flag;)</p>
<p>②初始化链表</p>
<p>一般i定义中的XXX进行初始化，将其初始化为正常情况下到达不了的数字(一般要小于所有能够到达的数字，理由在④中说明)，例如对结点是否在链表上的性质， 就要初始化为0(flag=false)，代表结点不在链表上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">    node[i].xxx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③通过题目给定的首地址，遍历一次整个链表，同时对xxx进行标记。</p>
<p>遍历一次整条链，并且对链表上的xxx进行标记、并且对有效结点的个数进行计数，例如对结点是否在链表上的性质，当我们遍历的时候可以设置为1(true); 并添加count变量统计此链表长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p = begin, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p != <span class="number">-1</span>) &#123;	<span class="comment">//-1代表链表结束</span></span><br><span class="line">	xxx = <span class="number">1</span>;</span><br><span class="line">	count++;</span><br><span class="line">	p = node[p]-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④使用静态链表，对链表进行排序。（静态链表+二级cmp排序）</p>
<p>静态链表使用hash表，所以很多结点并不是有效结点(可能存在不在链表上的结点)，为了可以控制有效结点，一般对数组进行排序可以把有效结点移到数组左端，这样可以使用count来访问结点。</p>
<p>需要把有效结点挪到前面就可以用xxx来帮忙。步骤②的时候xxx可以定义一个数字，这个数字比正常的xxx取值都小很多的数，这样写cmp的时候就可以在cmp的两个参数中又无效节点的时候按照xxx按照从大到小排序，就可以把有效数字都放到数组左边。</p>
<p>一般题目还会有其他要求，因此一般cmp会有二级排序，不过具体要看题目要求。例如题目要求把链表按照结点顺序排序，就需要在cmp中建立二级排序，cmp两个参数结点中有无效节点时候按照xxx从大到小排序 而两个参数结点都是有效结点的时候 按照结点在链表中的位置从小到大排序(结点顺序可以在第三步得到)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.xxx == <span class="number">-1</span> || b.xxx == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="comment">//至少一个结点是无效节点放在后面</span></span><br><span class="line">		<span class="keyword">return</span> a.xxx &gt; b.xxx; (xxx的定义可以在②中实现)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//均为有效结点进行二级排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑤经过步骤④后 有效结点在数组左端 并且按照结点的性质进行了排序 之后按照题目要求输出排序 （比较常见为按照各种不同的要求进行输出链表）</p>
<p>例子~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Given a constant K <span class="keyword">and</span> a singly linked <span class="built_in">list</span> L, you are supposed to reverse the links of every K elements on L. For example, given L being <span class="number">1</span>→<span class="number">2</span>→<span class="number">3</span>→<span class="number">4</span>→<span class="number">5</span>→<span class="number">6</span>, <span class="keyword">if</span> K=<span class="number">3</span>, then you must output <span class="number">3</span>→<span class="number">2</span>→<span class="number">1</span>→<span class="number">6</span>→<span class="number">5</span>→<span class="number">4</span>; <span class="keyword">if</span> K=<span class="number">4</span>, you must output <span class="number">4</span>→<span class="number">3</span>→<span class="number">2</span>→<span class="number">1</span>→<span class="number">5</span>→<span class="number">6.</span></span><br><span class="line"></span><br><span class="line">Input Specification:</span><br><span class="line">Each input file contains one test <span class="keyword">case</span>. For each <span class="keyword">case</span>, the first line contains the address of the first node, a positive N (≤<span class="number">10</span></span><br><span class="line">​<span class="number">5</span></span><br><span class="line">​​ ) which is the total number of nodes, <span class="keyword">and</span> a positive K (≤N) which is the length of the sublist to be reversed. The address of a node is a <span class="number">5</span>-digit nonnegative integer, <span class="keyword">and</span> <span class="literal">NULL</span> is represented by <span class="number">-1.</span></span><br><span class="line"></span><br><span class="line">Then N lines follow, each describes a node in the format:</span><br><span class="line"></span><br><span class="line">Address Data Next</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">where Address is the position of the node, Data is an integer, <span class="keyword">and</span> Next is the position of the next node.</span><br><span class="line"></span><br><span class="line">Output Specification:</span><br><span class="line">For each <span class="keyword">case</span>, output the resulting ordered linked <span class="built_in">list</span>. Each node occupies a line, <span class="keyword">and</span> is printed in the same format as in the input.</span><br><span class="line"></span><br><span class="line">Sample Input:</span><br><span class="line"><span class="number">00100</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">99999</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">12309</span></span><br><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">-1</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">00000</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">33218</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">Sample Output:</span><br><span class="line"><span class="number">00000</span> <span class="number">4</span> <span class="number">33218</span></span><br><span class="line"><span class="number">33218</span> <span class="number">3</span> <span class="number">12309</span></span><br><span class="line"><span class="number">12309</span> <span class="number">2</span> <span class="number">00100</span></span><br><span class="line"><span class="number">00100</span> <span class="number">1</span> <span class="number">99999</span></span><br><span class="line"><span class="number">99999</span> <span class="number">5</span> <span class="number">68237</span></span><br><span class="line"><span class="number">68237</span> <span class="number">6</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> address, data, next;</span><br><span class="line">	<span class="keyword">bool</span> flag;</span><br><span class="line">	<span class="keyword">int</span> order;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.order &lt; b.order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.order &gt; b.order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">		node[i].flag = <span class="literal">false</span>;</span><br><span class="line">		node[i].order = maxn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> first, n, k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;first, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> add;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;add);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;node[add].data, &amp;node[add].next);</span><br><span class="line">		node[add].address = add;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> temp = first;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(temp != <span class="number">-1</span>) &#123;</span><br><span class="line">		node[temp].flag = <span class="literal">true</span>;</span><br><span class="line">		node[temp].order = count++;</span><br><span class="line">		temp = node[temp].next;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(node, node + maxn, cmp);</span><br><span class="line">	<span class="keyword">int</span> tempnum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tempadd = first;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i=i+k) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; count/k * k) &#123;	<span class="comment">//还未到达最后一组 </span></span><br><span class="line">			sort(node + i, node+i+k, cmp2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i != count<span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>, node[i].address, node[i].data, node[i+<span class="number">1</span>].address);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>,node[i].address, node[i].data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤一：定义链表 bool性质定义flag </p>
<p>步骤二：初始化 flag均为false 初始化order</p>
<p>步骤三：遍历链表 标记flag为true 计算order 同时统计有效结点个数count</p>
<p>步骤四：对结点排序 cmp为对order排序 对有效结点使有效结点往前挪 对每个组内的有效结点进行排序sort(node + i, node+i+k, cmp2); 组内逆序</p>
<p>步骤五：有效结点已经按照数据域排序 因此直接输出就可以。</p>
<p>要注意最后一个结点的输出为-1避免%05d化为-00001</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/07/Dijkstra算法解决最短路径问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/07/Dijkstra算法解决最短路径问题/" itemprop="url">Dijkstra算法解决最短路径问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-07T16:18:25+08:00">
                2020-01-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单源最短路径问题：计算源点到其他各个顶点的最短路径长度</p>
<p>全局最短路径问题：图中任意两个节点之间的最短路径</p>
<p>以上两个问题均可以归结为最短路径问题(事实上对每个结点进行求单源最短路径就可以解决全局最短路径)</p>
<p>Dijkstra算法用于解决单源最短路径，但是不能求带负边权的最短路径。对于Dijkstra算法的基本含义，可以参考浙大数据结构的慕课的讲解，本文主要解决如何编程实现，以及编程模板，以及变式。</p>
<p>Dijkstra + DFS用于打印最短路径</p>
<p>先上伪代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//G[maxv][maxv]为图 设置为全局变量 dis为一维数组，为源点到各个顶点的最短路径长度(累积最优距离),s为起点</span></span><br><span class="line"><span class="comment">//inf为无穷大一般设置为999999999 maxv为顶点的个数(看题目要求)</span></span><br><span class="line">Dijkstra(G, dis[], s) &#123;</span><br><span class="line">	初始化(一般G[i][j]任意两个点均为inf 以及对其他数据的初始化多用fill函数)</span><br><span class="line">	<span class="keyword">for</span>(循环n次n为题目给出的顶点个数 一般与输入值有关) </span><br><span class="line">	&#123;</span><br><span class="line">		u = 使得dis[u]为最小值的且还未被访问的顶点标号;</span><br><span class="line">		<span class="comment">//使用一个for循环找u</span></span><br><span class="line">		记u已经被访问;	<span class="comment">//用一个bool数组记录</span></span><br><span class="line">		<span class="keyword">for</span>(从u出发能够达到的所有顶点v) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(v未被访问过 &amp;&amp; 以u为中介点使得s到顶点v的最短距离dis[v]更优)</span><br><span class="line">            优化dis[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图有两种存储格式，邻接矩阵或者邻接表，主要区别在对v结点的寻找注意区别。</p>
<p>需要提前定义全局变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">520</span>;	<span class="comment">//具体要看题目顶点数量的规模 一般要比最大的至少多20否则有可能会段错误</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">999999999</span>;</span><br></pre></td></tr></table></figure>
<p>接下来为两种模板:</p>
<p>①邻接矩阵版(笔者较为常用领接矩阵法):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//领接矩阵版</span></span><br><span class="line"><span class="keyword">int</span> n, G[maxv][maxv];	<span class="comment">//n为顶点数量fill(G[0], G[0] + maxv * maxv, inf);对图的初始化注意二维数组fill的写法</span></span><br><span class="line"><span class="keyword">int</span> dis[maxv];	<span class="comment">//当前起点到各个顶点累积最短距离</span></span><br><span class="line"><span class="keyword">int</span> pre[maxv];	<span class="comment">//用于记录当前结点的前一个结点</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;	<span class="comment">//用于记录当前节点是否被访问过 vis[i] == true为访问过 初值均为未被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;	<span class="comment">//s为起点</span></span><br><span class="line">    fill(dis, dis + MAXV, inf);	<span class="comment">//fill函数将一维数组赋值为inf(注意一维数组的写法dis后不加括号)</span></span><br><span class="line">	dis[s] = <span class="number">0</span>;	<span class="comment">//起始点到自身的距离为0 务必牢记 为算法的起点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;	<span class="comment">//循环n次</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, min = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;	<span class="comment">//使得dis[u]为最小值的且还未被访问的顶点标号;</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; dis[u] &lt; min) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;	<span class="comment">//如果没有找到小于inf的d[u] 说明剩下的剩余顶点和起点s不连通</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;	<span class="comment">//标记访问过u 即u已经被收进了已经访问的结点当中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">            <span class="comment">//如果v结点未被访问且经过u结点到达v可以使得dis[v]更加优(小)则更新dis[v]</span></span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf) &#123;</span><br><span class="line">               <span class="keyword">if</span>(dis[u] + G[u][v] &lt; dis[v]) &#123;	</span><br><span class="line">                	dis[v] = dis[u] + G[u][v];</span><br><span class="line">                   	pre[v] = u;	<span class="comment">//v的前一个结点为u</span></span><br><span class="line">            	&#125;</span><br><span class="line">                <span class="comment">//此处是关键后序会修改此处进行有多个标准时修改或者添加更新结点规则</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②领接表版(主要区别在于存储使用vector 对v的更新上也有些不同)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v, d;		<span class="comment">//v为目标顶点, Adj[i][j].d从i到Adj[i][j].v结点的边权 使用的存储结构不同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];		<span class="comment">//图G的领接表存储结构 Adj[u]存放从顶点u出发可以到达的所有顶点 Adj[u][j].v代表u可以到达该顶点标号 Adj[u][j].d为从i到Adj[i][j].v结点的边权</span></span><br><span class="line"><span class="keyword">int</span> n;	<span class="comment">//n为顶点数目(输入数据中) maxv为最大顶点数目(题目规定的规模)</span></span><br><span class="line"><span class="keyword">int</span> dis[maxv];	<span class="comment">//起点到各个顶点的最短距离长度(累积最短)</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;	<span class="comment">//标记数组 vis[i] == true 表示已经访问 初值为false</span></span><br><span class="line"><span class="keyword">int</span> pre[maxv];	<span class="comment">//用于记录前一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;		<span class="comment">//s为起点</span></span><br><span class="line">    fill(dis, dis + maxv, inf);		<span class="comment">//fill函数将整个d数组赋值为inf</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;	<span class="comment">//起始结点为0 为递归起点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, min = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找不到u说明与剩下结点不连通</span></span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;	<span class="comment">//标记本节点已经被访问 收入已访问结点中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Adj[u].size(); j++) &#123;	</span><br><span class="line">            <span class="comment">//此处遍历时直接获得u可以到达的结点为领接表优势注意从0-Adj[u].size();</span></span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; dis[u] + Adj[u][j].d &lt; dis[v]) &#123;	<span class="comment">//优化规则</span></span><br><span class="line">                dis[v] = dis[u] + Adj[u][j].d;</span><br><span class="line">                pre[v] = u;	<span class="comment">//v的前一个结点为u</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种结构打印最短路径pre[]数组中数据均使用dfs打印</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span> </span>&#123;	<span class="comment">//s为起点 v为当前访问的顶点编号 我们从终点开始递归 因为pre中存的都是前一个结点当全局变量中存放了其实结点s则可以直接写void dfs(int v)</span></span><br><span class="line">	<span class="keyword">if</span>(v == s) &#123;<span class="comment">//如果当前已经到达起始结点s 则输出并且返回</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(s, pre[v]);	<span class="comment">//递归访问v结点的前一个结点</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v);	<span class="comment">//从最终起点层返回回来后执行上一层(次起点层)的顶点 就可以获得从起点开始的顺序序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下总结三种考察方法:两种标尺进行对多种路径的淘汰和筛选使得结果唯一。即对于题目有两种及以上的路径满足第一标尺时候，题目会给出第二个甚至更多等级的标尺进行对重复的路径筛选。以第二标尺为例，更多重可以类推。</p>
<p><strong>对于第二标尺的出题方法，我们都只需要增加一个数组来存放新增的边权或者点权或者是最短路径的条数，然后只要在Dijkstra算法中修改对d[v]的步骤即可，其他不用动按模板写就可以。</strong></p>
<p>常见三种类型:</p>
<p>①给每条边增加一个边权(cost 如距离为第一标尺 则添加路费为第二标尺)，题目则要求在距离最短的路径中有多条的时候要求在路径上花费之和最小。(如果有其他边权含义也可以是总cost最大，例如可以添加在每条路径上路过的树的数量最多…)</p>
<p>实现的时候增加cost[maxv][maxv]代表代表u→v的花费图(题目输入)并且增加一个c[]用于存放从起点u到各个顶点的累积花费。(其实原理和距离的很像G[u][v]为距离图 dis[]为源点到各个顶点的累积距离)</p>
<p><strong>重点是对值的初始化问题：初始化时c[s]为0、其余c[u]为inf 对花费图cost[u][v]初试为inf 再把题目输入的去更新对应的数值即可(求花费最少为第二标尺时)。</strong>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">	<span class="comment">//如果v未被访问 &amp;&amp; u可以到达v</span></span><br><span class="line">	<span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf) &#123;</span><br><span class="line">       <span class="keyword">if</span>(dis[u] + G[u][v] &lt; dis[v])&#123;</span><br><span class="line">			dis[v] = dis[u] + G[u][v];		</span><br><span class="line">			c[v] = c[u] + cost[u][v];<span class="comment">//距离是第一标尺当第一标尺无冲突的时第二标尺无条件服从第一标尺</span></span><br><span class="line">			pre[v] = u;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u] + G[u][v] == d[v] &amp;&amp; c[u] + cost[u][v] &lt; c[v])&#123; </span><br><span class="line">        <span class="comment">//最短距离相同的时候看是否可以让c[v]更佳可以则更新c[v]</span></span><br><span class="line">			c[v] = c[u] + cost[u][v];</span><br><span class="line">        	pre[v] = u;</span><br><span class="line">	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②新增点权。当给定每个点权(第二标尺) 要求在最短路径上有多条的时候要求点权最大。如每个顶点有物资，要求最短路径有多条的时候要求路径上点权之和最大(如果点权是其他含义也可以是最小)</p>
<p>增加一个点权的几何weigh[u]代表城市u的点权大小,并且增加w[]代表从源点到达目标城市收集的最大物资(最大累积点权和)</p>
<p><strong>初始化规则：只有w[s]为weight[s]其他均为w[u]=0。</strong>更新规则如下展示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[u] + G[u][v] &lt; dis[v]) &#123;</span><br><span class="line">            dis[v] = dis[u] + G[u][v];</span><br><span class="line">            w[v] = weight[v] + w[u];	<span class="comment">//当第一标尺无冲突 无条件修改点权</span></span><br><span class="line">            pre[v] = u;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + G[u][v] == dis[v] &amp;&amp; weight[v] + w[u] &gt; w[v])&#123;</span><br><span class="line">            w[v] = w[u] + weight[v];	<span class="comment">//第一标尺最短距离相同的时候 可以使得w[v]更优更新</span></span><br><span class="line">            pre[v] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③新增求最短路径的条数。题目一般会直接问最短路径的条数为多少条。</p>
<p>只需要增加一个数组num[]令从起点s到达顶点u的最短路径的条数为num[u] </p>
<p><strong>初始化时只需要有num[s]=1、其余num[u]均为0.</strong>即可在dis[u] + G[u][v] &lt; dis[u]的时候更新dis[v]并且让num[v]继承num[u],而当d[u] + G[u][v] == d[v]的时候(最短路径相同的时候)将num[u]加到num[v]上。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dis[u] + G[u][v] &lt; dis[v]) &#123;</span><br><span class="line">            d[v] = d[u] + G[u][v];</span><br><span class="line">            num[v] = num[u];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + G[u][v] == dis[v]) &#123;</span><br><span class="line">            num[v] = num[v] + num[u];<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细的读者可能发现此处没有保存每个节点的前驱节点 因为有多条路径下文会介绍一种更好的方法来保存和输出所有最小路径(如果有多条的情况)</p>
<p>先来一个例子汇总一下这三个考法:</p>
<p>e.g. 要求路径最短 又要保证点权之和最大 而且还要输出最短路径的个数 还要输出路径 保证第二权重确定后路径唯一。(考题往往出的比这还复杂)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[u] + G[u][v] &lt; dis[v]) &#123;</span><br><span class="line">            dis[v] = dis[u] + G[u][v];</span><br><span class="line">            w[v] = w[u] + weight[v];</span><br><span class="line">            num[v] = num[u];</span><br><span class="line">            pre[v] = u;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + G[u][v] == dis[v]) &#123;</span><br><span class="line">            num[v] = num[v] + num[u];</span><br><span class="line">            <span class="keyword">if</span>(w[v] &lt; w[u] + weight[v]) &#123;	<span class="comment">//只有权重更优的时候才更新 题目保证了唯一</span></span><br><span class="line">            	w[v] = w[u] + weight[v];</span><br><span class="line">            	pre[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;	<span class="comment">//逆序存放 递归逆序打印</span></span><br><span class="line">    <span class="keyword">if</span>(v == s) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, v);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    printPath(pre[v]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样无法获得多条路径(可能存在多条路径 这种编程方式只是题目确保了唯一)当有多条路径的时候要使用vector数组在存放。</p>
<p>也可以不这么麻烦(当然以上的是必须要牢固背下来理解下来的，但也可以使用。以下要介绍一种更为方便的思路Dijkstra+DFS。即用Dijkstra求出最短路径还有pre数组，然后使用深度优先遍历来求想要的一切，包括点权最大，边权最大、路径个数、打印数据</p>
<p>可能有多条路径所以Dijkstra算法中pre数组用vector<int>存放pre[maxv]。以下写法分两步</int></p>
<p>①Dijkstra算法求最短路径 存储前驱节点在vector中</p>
<p>在Dijkstra函数中求前驱节点pre[maxv]此处保留相同长度的路径节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[maxv]; <span class="comment">//事先需要声明 vector&lt;int&gt; pre[maxv];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra部分需要修改使得多种路径的方式存储在vector中</span></span><br><span class="line"><span class="keyword">if</span>(dis[u] + G[u][v] &lt; dis[v]) &#123;</span><br><span class="line">    dis[v] = dis[u] + G[u][v];</span><br><span class="line">    pre[v].clear();		<span class="comment">//因为有更好的故淘汰原来的最优前驱点</span></span><br><span class="line">    pre[v].push_back(u);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(dis[i] + G[u][v] == dis[v]) &#123;</span><br><span class="line">    pre[v].push_back(u);	<span class="comment">//当距离相同的时候有了相同距离的前驱节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的Dijkstra函数如下(要会完整的写出来)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[maxv];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;		<span class="comment">//s为起点</span></span><br><span class="line">	fill(dis, dis + maxv, inf);		<span class="comment">//距离第一标尺初始化</span></span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">-1</span>, min = inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">				u = j;</span><br><span class="line">				min = dis[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf) &#123;</span><br><span class="line">				<span class="keyword">if</span>(dis[u] + G[u][v] &lt; dis[v]) &#123;</span><br><span class="line">					dis[v] = dis[u] + G[u][v];</span><br><span class="line">					pre[v].clear();	<span class="comment">//清空v前驱</span></span><br><span class="line">					pre[v].push_back(u);	<span class="comment">//令v的前驱为u	</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + G[u][v] == d[v]) &#123;</span><br><span class="line">					pre[v].push_back(u);	<span class="comment">//相同距离的前驱节点多了一个 故令v的前驱节点添加一个u</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②求得了pre数组，就可以得知所有的最短路径，然后使用dfs去遍历所有的最短路径，找出一条使第二标尺最优的路径。</p>
<p>每次遍历到达叶子节点就会产生一条完整的最短路径。计算每一条的路径的第二标尺的值。并在每次遍历过程中保存最优的第二标尺值(不断更新最优标尺值)，这样遍历完所有的路径就可以获得最优的第二标尺与最优的路径。</p>
<p>考虑些dfs递归函数:</p>
<p>三个部分</p>
<p>（1）作为全局变量的第二标尺最优值 optValue</p>
<p>（2）记录最优路径的数组path(使用vector来存储)因为vector可以直接赋值</p>
<p>（3）临时记录dfs遍历到达叶子节点时的路径tempPath(也用vector存储)</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> optValue;	<span class="comment">//第二标尺最优值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[maxv];	<span class="comment">//存放结点的前驱结点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, tempPath;	<span class="comment">//最优路径 临时路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span>	</span>&#123;	<span class="comment">//v为当前访问结点</span></span><br><span class="line">	<span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">if</span>(v == s) &#123;	<span class="comment">//如果到达s叶子节点(即路径的起始结点)</span></span><br><span class="line">        tempPath.push_back(v);	<span class="comment">//起始结点加入临时路径tempPath最后 到达起始点将v给亚茹堆栈tempPath中 </span></span><br><span class="line">        <span class="keyword">int</span> value = tempPath上的value值;</span><br><span class="line">        <span class="keyword">if</span>(value 优于 opValue) &#123;</span><br><span class="line">            opValue = value;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();	<span class="comment">//刚刚加入的起始结点删除保证了每一层既把本层的结点push也把本层的结点pop</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归式</span></span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].size(); i++) &#123;</span><br><span class="line">        dfs(pre[v][i]);	<span class="comment">//pre[v][i]在下一层dfs中被push和pop</span></span><br><span class="line">    &#125;	<span class="comment">//dfs保证了一路算到底到v == s 使得每一条都被算过</span></span><br><span class="line">    tempPath.pop_back();	<span class="comment">//pop为吧本层v结点pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）对于递归边界。tempPath为保存一条完整的路径，如果访问到的本层为一个叶子结点就是当前路径的开始结点 说明到达递归边界 <strong>把起始结点vpush进入堆栈tempPath 此时tempPath就有了一条完整的路径</strong>，如果计算得到的value值大于最大值optValue则path = tempPath 保存路径维护path为为当前的最优路径，并且要把tempPath中最后一个结点(起始) 再return 来进行之后的递归。</p>
<p>（2）<strong>对于递归式，每一次为把当前访问的结点压入，然后找本层结点的pre[v][i]进行递归操作，递归完毕以后弹出最后一个结点。</strong></p>
<p>（3）计算当前tempPath边权或者点权之和的代码：(不同value值的算法)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在dfs中计算value值</span></span><br><span class="line"><span class="comment">//边权之和</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;	</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = tempPath.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = tempPath[i], idnext = tempPath[i - <span class="number">1</span>];</span><br><span class="line">    value += v[id][idnext];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点权之和</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = tempPath.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = tempPath[i];	<span class="comment">//当前结点id</span></span><br><span class="line">    value += weight[id];	<span class="comment">//value增加结点id的点权。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后以一个例子结束本篇文章:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">题目: Travel Plan </span><br><span class="line">A traveler&apos;s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</span><br><span class="line"></span><br><span class="line">Input Specification:</span><br><span class="line">Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:</span><br><span class="line"></span><br><span class="line">City1 City2 Distance Cost</span><br><span class="line">    </span><br><span class="line">where the numbers are all integers no more than 500, and are separated by a space.</span><br><span class="line"></span><br><span class="line">Output Specification:</span><br><span class="line">For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</span><br><span class="line"></span><br><span class="line">Sample Input:</span><br><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br><span class="line"></span><br><span class="line">Sample Output:</span><br><span class="line">0 2 3 3 40</span><br></pre></td></tr></table></figure>
<p>第一种写法(传统直接Dijkstra 第二标尺也在Dijkstra中实现)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">999999999</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">520</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, d;		<span class="comment">//n为城市的数量 m为高速公路的数量 s为开始的城市 d为结束的城市 </span></span><br><span class="line"><span class="keyword">int</span> G[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> w[maxv];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cost[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> c[maxv];</span><br><span class="line"><span class="keyword">int</span> prepath[maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; disprepath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsprepath</span><span class="params">(<span class="keyword">int</span> vcity)</span> </span>&#123;</span><br><span class="line">	disprepath.push_back(vcity);</span><br><span class="line">	<span class="keyword">if</span>(vcity == s) <span class="keyword">return</span>;</span><br><span class="line">	dfsprepath(prepath[vcity]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxv * maxv, inf);</span><br><span class="line">	fill(cost[<span class="number">0</span>], cost[<span class="number">0</span>] + maxv * maxv, inf);</span><br><span class="line">	fill(w, w + maxv, inf);</span><br><span class="line">	fill(c, c + maxv, inf);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> c1, c2, Dis, Cost;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; Dis &gt;&gt; Cost;</span><br><span class="line">		G[c1][c2] = G[c2][c1] = Dis;</span><br><span class="line">		cost[c1][c2] = cost[c2][c1] = Cost; </span><br><span class="line">	&#125;</span><br><span class="line">	w[s] = <span class="number">0</span>;</span><br><span class="line">	c[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		prepath[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">-1</span>, min = inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; w[j] &lt; min) &#123;</span><br><span class="line">				u = j;</span><br><span class="line">				min = w[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] &lt; inf) &#123;</span><br><span class="line">				<span class="keyword">if</span>(G[u][v] + w[u] &lt; w[v]) &#123;</span><br><span class="line">					w[v] = G[u][v] + w[u];</span><br><span class="line">					c[v] = cost[u][v] + c[u];</span><br><span class="line">					prepath[v] = u;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (G[u][v] + w[u] == w[v] &amp;&amp; cost[u][v] + c[u] &lt; c[v]) &#123;</span><br><span class="line">					c[v] = cost[u][v] + c[u];</span><br><span class="line">					prepath[v] = u;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	dfsprepath(d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = disprepath.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, disprepath[i]);</span><br><span class="line">		<span class="keyword">if</span>(i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" %d %d"</span>, w[d], c[d]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种(Dijkstra+DFS 。Dijkstra中计算最短路径 在DFS中计算第二标尺筛选路径)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">520</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">999999999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, d;</span><br><span class="line"><span class="keyword">int</span> G[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> dis[maxv];</span><br><span class="line"><span class="keyword">int</span> cost[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> c[maxv];</span><br><span class="line"><span class="keyword">int</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prepath[maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, temppath;</span><br><span class="line"><span class="keyword">int</span> optivalue = inf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">	fill(dis, dis + maxv, inf);</span><br><span class="line">	dis[st] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">-1</span>, min = inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; min) &#123;</span><br><span class="line">				u = j;</span><br><span class="line">				min = dis[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">		vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[v] == <span class="literal">false</span> &amp;&amp; G[u][v] != inf) &#123;</span><br><span class="line">				<span class="keyword">if</span>(G[u][v] + dis[u] &lt; dis[v]) &#123;</span><br><span class="line">					dis[v] = G[u][v] + dis[u];</span><br><span class="line">					prepath[v].clear();</span><br><span class="line">					prepath[v].push_back(u);</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(G[u][v] + dis[u] == dis[v]) &#123;</span><br><span class="line">					prepath[v].push_back(u);	<span class="comment">//多条路径 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//递归边界 </span></span><br><span class="line">	<span class="keyword">if</span>(v == s) &#123;</span><br><span class="line">		temppath.push_back(v);	<span class="comment">//起始结点入栈以后temppath中为完整的路径 </span></span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;	<span class="comment">//边权最大值 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = temppath.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> c1, c2;</span><br><span class="line">			c1 = temppath[i];</span><br><span class="line">			c2 = temppath[i - <span class="number">1</span>];</span><br><span class="line">			value = value + cost[c1][c2];</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(value &lt; optivalue) &#123;</span><br><span class="line">			path = temppath;	<span class="comment">//为倒叙的序列</span></span><br><span class="line">			optivalue = value;</span><br><span class="line">		&#125; </span><br><span class="line">		temppath.pop_back();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//递归式</span></span><br><span class="line">	temppath.push_back(v);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = prepath[v].size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		DFS(prepath[v][i]);</span><br><span class="line">	&#125; </span><br><span class="line">	temppath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;d);</span><br><span class="line">	fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + maxv * maxv, inf);</span><br><span class="line">	fill(cost[<span class="number">0</span>], cost[<span class="number">0</span>] + maxv * maxv, inf);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> c1, c2, Dis, Cost;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;c1, &amp;c2, &amp;Dis, &amp;Cost);</span><br><span class="line">		G[c1][c2] = G[c2][c1] = Dis;</span><br><span class="line">		cost[c1][c2] = cost[c2][c1] = Cost;</span><br><span class="line">	&#125;</span><br><span class="line">	Dijkstra(s);	<span class="comment">//获得前驱路径</span></span><br><span class="line">	DFS(d); </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = path.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, path[i]);</span><br><span class="line">		<span class="keyword">if</span>(i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" %d %d"</span>, dis[d], optivalue);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上 有问题欢迎留言。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/Python学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gao Lijie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GaoLijie's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/Python学习/" itemprop="url">Python学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T15:24:40+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、基本</p>
<p>1.if</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = -2</span><br><span class="line">y = 2</span><br><span class="line">z = 3</span><br><span class="line">if x &gt; 1:</span><br><span class="line">    print(&apos;x &gt; 1&apos;)</span><br><span class="line">elif x &lt; -1: </span><br><span class="line">    print(&apos;x &lt; -1&apos;)</span><br><span class="line">elif x &lt; 1:</span><br><span class="line">    print(&apos;x &lt; 1&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;x = 1&apos;)</span><br><span class="line">print(&apos;finish running&apos;)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x &lt; -1</span><br><span class="line">finish running</span><br></pre></td></tr></table></figure>
<p>要注意 只会第一条语句满足以后就跳出 </p>
<p>而且要注意的是if-elif-else为一个整体 要注意缩进 缩进以后的格式才能是整体的语句执行。</p>
<p>二、函数定义</p>
<p>1.def函数</p>
<p>函数定义的时候用的语句是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def function(a):</span><br></pre></td></tr></table></figure>
<p>一定定义的函数 要是在四个空格空着的缩进 还有一个冒号必须要在冒号下面函数内有四个空格的缩进 才是定义函数内部的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def function(a, b):</span><br><span class="line">    print(&quot;This is a function&quot;)</span><br><span class="line">    a = 1+2</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>没有结果 函数要调用以后才能运行因此在shell中进行调用才可以有输出</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function()</span><br></pre></td></tr></table></figure>
<p>或在函数脚本中直接运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def function():</span><br><span class="line">    print(&quot;This is a function&quot;)</span><br><span class="line">    a = 1+2</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">function()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is a function</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    c = a * b</span><br><span class="line">    print(a,b)</span><br><span class="line">    print(<span class="string">'the c is'</span>, c)</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun(2,5)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun(a=2, b=5)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun(b=5, a=2)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">the c is 10</span><br></pre></td></tr></table></figure>
<p>2.函数默认参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sale_car</span><span class="params">(price, colour, brand, is_second_hand)</span>:</span></span><br><span class="line">    print(<span class="string">'price:'</span>,price,</span><br><span class="line">          <span class="string">'colour:'</span>,colour,</span><br><span class="line">          <span class="string">'brand:'</span>,brand,</span><br><span class="line">          <span class="string">'is_second_hand:'</span>,is_second_hand,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sale_car(<span class="number">1000</span>, <span class="string">'red'</span>, <span class="string">'carmy'</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price: 1000 colour: red brand: carmy is_second_hand: True</span><br></pre></td></tr></table></figure>
<p>注意参数多 可以分行书写 但是记得缩进</p>
<p>当有默认参数时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sale_car</span><span class="params">(price, colour = <span class="string">'red'</span>, brand = <span class="string">'carmy'</span>, is_second_hand = True)</span>:</span></span><br><span class="line">    print(<span class="string">'price:'</span>,price,</span><br><span class="line">          <span class="string">'colour:'</span>,colour,</span><br><span class="line">          <span class="string">'brand:'</span>,brand,</span><br><span class="line">          <span class="string">'is_second_hand:'</span>,is_second_hand,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sale_car(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price: 1000 colour: red brand: carmy is_second_hand: True</span><br></pre></td></tr></table></figure>
<p>这个时候还是默认值 而且输入值1000</p>
<p>如果输入覆盖默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sale_car</span><span class="params">(price, colour = <span class="string">'red'</span>, brand = <span class="string">'carmy'</span>, is_second_hand = True)</span>:</span></span><br><span class="line">    print(<span class="string">'price:'</span>,price,</span><br><span class="line">          <span class="string">'colour:'</span>,colour,</span><br><span class="line">          <span class="string">'brand:'</span>,brand,</span><br><span class="line">          <span class="string">'is_second_hand:'</span>,is_second_hand,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sale_car(<span class="number">1000</span>, colour = <span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price: 1000 colour: blue brand: carmy is_second_hand: True</span><br></pre></td></tr></table></figure>
<p>此时也可以写输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sale_car(1000, &apos;blue&apos;)</span><br></pre></td></tr></table></figure>
<p>后面默认值还是没有变</p>
<p>注意：定义默认值的时候 在函数定义的时候必须将未定义的放在已经定义默认值的变量的前面否则会报错</p>
<p>输入值的时候也要改变顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sale_car</span><span class="params">(price, brand, colour = <span class="string">'red'</span>, is_second_hand = True)</span>:</span></span><br><span class="line">    print(<span class="string">'price:'</span>,price,</span><br><span class="line">          <span class="string">'colour:'</span>,colour,</span><br><span class="line">          <span class="string">'brand:'</span>,brand,</span><br><span class="line">          <span class="string">'is_second_hand:'</span>,is_second_hand,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sale_car(<span class="number">1000</span>, <span class="string">'BMW'</span>, colour = <span class="string">'blue'</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">price: 1000 colour: blue brand: BMW is_second_hand: True</span><br></pre></td></tr></table></figure>
<p>3.函数返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    print(a)</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(fun())</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">110</span><br></pre></td></tr></table></figure>
<p>3.全局/局部变量</p>
<p>全局变量一般全部使用大写放在文档的开头 函数外部可以调用局部变量</p>
<p>在函数内部的变量就是局部的变量 在函数外部无法调用局部变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">APPLE = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    print(a)</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(APPLE)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>此时报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">APPLE = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    a = APPLE</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(APPLE)</span><br><span class="line">print(fun())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>如果非要在函数内部定义函数变量</p>
<p>那么就要在开头定义出来以后在函数内假设一个global</p>
<p>栗子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">APPLE = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">a = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(APPLE)</span><br><span class="line">print(<span class="string">'a past='</span>, a)</span><br><span class="line">print(fun())</span><br><span class="line">print(<span class="string">'a now='</span>, a)</span><br></pre></td></tr></table></figure>
<p>在还没调用函数前 a仍然为none</p>
<p>当调用函数后 函数中定义了a 以后 a为20 同时 输出fun后我们输出a的值就是20</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">a past= None</span><br><span class="line">120</span><br><span class="line">a now= 20</span><br></pre></td></tr></table></figure>
<p>4.元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tuple list</span></span><br><span class="line"></span><br><span class="line">a_tuple = (<span class="number">12</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">6</span>)</span><br><span class="line">another_tuple = <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line"></span><br><span class="line">a_list = [<span class="number">12</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">7</span>,<span class="number">82</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(a_tuple)):</span><br><span class="line">    print(<span class="string">'index='</span>,index,<span class="string">'number in list='</span>,a_list[index])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index= 0 number in list= 12</span><br><span class="line">index= 1 number in list= 3</span><br><span class="line">index= 2 number in list= 67</span><br><span class="line">index= 3 number in list= 7</span><br><span class="line">index= 4 number in list= 82</span><br></pre></td></tr></table></figure>
<p>4.列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">a.append(<span class="number">0</span>) <span class="comment">#在a后面追加一个0</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a.insert(<span class="number">1</span>, <span class="number">0</span>)  <span class="comment">#在指定位置1添加0 </span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">a.remove(<span class="number">2</span>) <span class="comment">#列表中第一个2去掉</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(a[<span class="number">0</span>]) <span class="comment">#打印出a中第0位</span></span><br><span class="line"></span><br><span class="line">print(a[<span class="number">-1</span>])    <span class="comment">#-1代表最后一位的数字 是python的特点</span></span><br><span class="line"></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">3</span>])   <span class="comment">#代表从第0位开始到第三位之前 左闭右开</span></span><br><span class="line"></span><br><span class="line">print(a[:<span class="number">3</span>])    <span class="comment">#打印开头三位</span></span><br><span class="line"></span><br><span class="line">print(a[<span class="number">3</span>:<span class="number">5</span>])   <span class="comment">#打印第34位</span></span><br><span class="line"></span><br><span class="line">print(a[<span class="number">5</span>:])    <span class="comment">#打印第5位到最后的数字</span></span><br><span class="line"></span><br><span class="line">print(a[<span class="number">-3</span>:])   <span class="comment">#倒数第3位到最后一位的数字</span></span><br><span class="line"></span><br><span class="line">print(a.index(<span class="number">2</span>))      <span class="comment">#列表中第一次出现2的索引下标</span></span><br><span class="line"></span><br><span class="line">print(a.count(<span class="number">1</span>))   <span class="comment">#统计列表中2出现的次数</span></span><br><span class="line"></span><br><span class="line">a.sort()    <span class="comment">#从小到大排序a并且覆盖原有的a</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">a.sort(reverse=<span class="keyword">True</span>)    <span class="comment">#从大到小排序 原来reverse为Fales</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 2, 3, 1, 1, 0]</span><br><span class="line">[1, 0, 2, 3, 4, 2, 3, 1, 1, 0]</span><br><span class="line">[1, 0, 3, 4, 2, 3, 1, 1, 0]</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">[1, 0, 3]</span><br><span class="line">[1, 0, 3]</span><br><span class="line">[4, 2]</span><br><span class="line">[3, 1, 1, 0]</span><br><span class="line">[1, 1, 0]</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">[0, 0, 1, 1, 1, 2, 3, 3, 4]</span><br><span class="line">[4, 3, 3, 2, 1, 1, 1, 0, 0]</span><br></pre></td></tr></table></figure>
<p>5.多维列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">multi_dim_a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">               [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">               [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">print(a[<span class="number">0</span>])</span><br><span class="line">print(multi_dim_a[<span class="number">2</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>6.字典</p>
<p>字典是一个没有顺序的东西</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">d = &#123;<span class="string">'apple'</span>:<span class="number">1</span>, <span class="string">'pear'</span>:<span class="number">2</span>, <span class="string">'orange'</span>:<span class="number">3</span>&#125;</span><br><span class="line">d2 = &#123;<span class="number">1</span>:<span class="string">'a'</span>, <span class="number">2</span>:<span class="string">'b'</span>, <span class="string">'c'</span>:<span class="string">'b'</span>&#125;   <span class="comment">#要有一个key 一个内容有点像哈希表</span></span><br><span class="line"></span><br><span class="line">print(d[<span class="string">'apple'</span>])</span><br><span class="line">print(a_list[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">d[<span class="string">'b'</span>] = <span class="number">20</span>  <span class="comment">#往字典当中去加 输出的时候没有按顺序</span></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">'pear'</span>] <span class="comment">#删除字典元素</span></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">d3 = &#123;<span class="string">'apple'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">'pear'</span>:&#123;<span class="number">1</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="string">'a'</span>&#125;, <span class="string">'orange'</span>:<span class="number">2</span>&#125;  <span class="comment">#字典里面可以加字典</span></span><br><span class="line">print(d3)</span><br><span class="line"></span><br><span class="line">print(d3[<span class="string">'pear'</span>][<span class="number">3</span>]) <span class="comment">#在pear中找3</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="string">'apple'</span>: <span class="number">1</span>, <span class="string">'pear'</span>: <span class="number">2</span>, <span class="string">'orange'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">20</span>&#125;</span><br><span class="line">&#123;<span class="string">'apple'</span>: <span class="number">1</span>, <span class="string">'orange'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">20</span>&#125;</span><br><span class="line">&#123;<span class="string">'apple'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">'pear'</span>: &#123;<span class="number">1</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="string">'a'</span>&#125;, <span class="string">'orange'</span>: <span class="number">2</span>&#125;</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>7.import模块</p>
<p>1)加载模块第一种方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">print(time.localtime())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2019</span>, tm_mon=<span class="number">5</span>, tm_mday=<span class="number">11</span>, tm_hour=<span class="number">15</span>, tm_min=<span class="number">54</span>, tm_sec=<span class="number">21</span>, tm_wday=<span class="number">5</span>, tm_yday=<span class="number">131</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>2)加载 长的模块名为短模块名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> t</span><br><span class="line"></span><br><span class="line">print(t.localtime())</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2019</span>, tm_mon=<span class="number">5</span>, tm_mday=<span class="number">11</span>, tm_hour=<span class="number">15</span>, tm_min=<span class="number">55</span>, tm_sec=<span class="number">49</span>, tm_wday=<span class="number">5</span>, tm_yday=<span class="number">131</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>3)只import部分功能后面调用功能可以直接调用函数 不必调用模块名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, localtime</span><br><span class="line"></span><br><span class="line">print(localtime())</span><br><span class="line">print(time())</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=2019, tm_mon=5, tm_mday=11, tm_hour=15, tm_min=59, tm_sec=2, tm_wday=5, tm_yday=131, tm_isdst=0)</span><br><span class="line">1557561542.2265193</span><br></pre></td></tr></table></figure>
<p>4)import所有功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">print(localtime())</span><br><span class="line">print(time())</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=2019, tm_mon=5, tm_mday=11, tm_hour=16, tm_min=1, tm_sec=12, tm_wday=5, tm_yday=131, tm_isdst=0)</span><br><span class="line">1557561672.3201375</span><br></pre></td></tr></table></figure>
<p>8.引用自己的模块</p>
<p>Test3中写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printdata</span><span class="params">(data)</span>:</span></span><br><span class="line">    print(<span class="string">'I am test3'</span>)</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>
<p>test4中调用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test3</span><br><span class="line"></span><br><span class="line">test3.printdata(<span class="string">'I am python1'</span>)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am test3</span><br><span class="line"></span><br><span class="line">I am python1</span><br></pre></td></tr></table></figure>
<p>python有默认的模块在lib site-packages的位置 这里可以直接调用模块 还有一个是在编程文档也可以直接调用</p>
<p>9.continue &amp; break</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> a:</span><br><span class="line">    b = input(<span class="string">'type something:'</span>)</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">'1'</span>:</span><br><span class="line">        a = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        print(<span class="string">'still in while'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'finishi run'</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type something:<span class="number">2</span></span><br><span class="line">still <span class="keyword">in</span> <span class="keyword">while</span></span><br><span class="line">type something:<span class="number">3</span></span><br><span class="line">still <span class="keyword">in</span> <span class="keyword">while</span></span><br><span class="line">type something:<span class="number">1</span></span><br><span class="line">finishi run</span><br></pre></td></tr></table></figure>
<p>continue是跳过后序的语句进入下一次循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> a:</span><br><span class="line">    b = input(<span class="string">'type something:'</span>)</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">'1'</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        print(<span class="string">'still in while'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'finishi run'</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type something:1</span><br><span class="line">type something:2</span><br><span class="line">still in while</span><br><span class="line">type something:</span><br></pre></td></tr></table></figure>
<p>break是直接退出循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> a:</span><br><span class="line">    b = input(<span class="string">'type something:'</span>)</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">'1'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'still in while'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'finishi run'</span>)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type something:5</span><br><span class="line">still in while</span><br><span class="line">type something:1</span><br><span class="line">finishi run</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> a:</span><br><span class="line">    b = input(<span class="string">'type something:'</span>)</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">'1'</span>:</span><br><span class="line">        a = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'still in while'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'finishi run'</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type something:2</span><br><span class="line">still in while</span><br><span class="line">type something:1</span><br><span class="line">still in while</span><br><span class="line">finishi run</span><br></pre></td></tr></table></figure>
<p>此时注意仍然会执行 false后面并列语句 break直接退出本轮</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">while</span> a:</span><br><span class="line">    b = input(<span class="string">'type something:'</span>)</span><br><span class="line">    <span class="keyword">if</span> b == <span class="string">'1'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">'still in while'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'finishi run'</span>)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type something:5</span><br><span class="line">still in while</span><br><span class="line">type something:6</span><br><span class="line">still in while</span><br><span class="line">type something:1</span><br><span class="line">finishi run</span><br></pre></td></tr></table></figure>
<p>10.try语句的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    file = open(&apos;eeee&apos;, &apos;r&apos;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file = open(<span class="string">'eeeeee.txt'</span>, <span class="string">'r+'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'there is no file named as eeeeee'</span>)</span><br><span class="line">    response = input(<span class="string">'do you want to create a new file:'</span>)</span><br><span class="line">    <span class="keyword">if</span> response == <span class="string">'y'</span>:</span><br><span class="line">        file = open(<span class="string">'eeeeee.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:   <span class="comment">#except下一半</span></span><br><span class="line">    file.write(<span class="string">'ssss'</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">there is no file named as eeeeee</span><br><span class="line">do you want to create a new file:y</span><br></pre></td></tr></table></figure>
<p>运行两次就会发现写入了ssss</p>
<p>11.zip lambda map</p>
<p>1)zip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; zip(a,b)</span><br><span class="line">&lt;zip object at 0x00000201D5DE9F88&gt;</span><br><span class="line">&gt;&gt;&gt; list(zip(a,b))</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; for i,j in zip(a,b):</span><br><span class="line">	print(i/2, j*2)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">0.5 8</span><br><span class="line">1.0 10</span><br><span class="line">1.5 12</span><br><span class="line">&gt;&gt;&gt; list(zip(a,a,b))</span><br><span class="line">[(1, 1, 4), (2, 2, 5), (3, 3, 6)]</span><br></pre></td></tr></table></figure>
<p>2)lambda</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(x,y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span>(x+y)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun2 = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun2(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>lambda可以用于定义简单的方程 一行搞定</p>
<p>3)map用于可以直接调用函数计算 并且可以多次并列计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; map(fun1, [1], [2])</span><br><span class="line">&lt;map object at 0x00000201D5E5E358&gt;</span><br><span class="line">&gt;&gt;&gt; list(map(fun1,[1],[2]))</span><br><span class="line">[3]</span><br><span class="line">&gt;&gt;&gt; list(map(fun1,[1,3],[2,5]))</span><br><span class="line">[3, 8]</span><br></pre></td></tr></table></figure>
<p>但是要在list当中才可以输出数字 否则只是一个object的地址</p>
<p>12.copy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = a</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">2206907044488</span><br><span class="line">&gt;&gt;&gt; id(b)</span><br><span class="line">2206907044488</span><br><span class="line">&gt;&gt;&gt; b[0] = 11</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[11, 2, 3]</span><br><span class="line">&gt;&gt;&gt; a[1] = 22</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[11, 22, 3]</span><br><span class="line">&gt;&gt;&gt; print(id(a) == id(b))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; c = copy.copy(a)</span><br><span class="line">&gt;&gt;&gt; print(id(a)==id(c))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; c[1] = 222222</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[11, 22, 3]</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[11, 222222, 3]</span><br><span class="line">&gt;&gt;&gt; a = [1, 2, [3,4]]</span><br><span class="line">&gt;&gt;&gt; d = copy.copy(a)</span><br><span class="line">&gt;&gt;&gt; id(a) == id(d)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; id(a[2]) == id(d[2])</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a[0] = 11</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[11, 22, 3]</span><br><span class="line">&gt;&gt;&gt; a[2][0] = 333</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">[1, 2, [333, 4]]</span><br><span class="line">&gt;&gt;&gt; e = copy.deepcopy(a)</span><br><span class="line">&gt;&gt;&gt; id(e[2]) == id(a[2])</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>如果是a = b则是指向同一个地址的意思 完完全全的复制</p>
<p>copy分为 浅复制与深复制</p>
<p>浅赋值 copy.copy  第一层地址不复制 不指向同一个地址 第二层地址复制 指向同一个地方</p>
<p>深复制 copy.deepcopy  全部都不指向同一个地址 </p>
<p>13.pickle用于保存内存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">a_dict = &#123;<span class="string">'da'</span>: <span class="number">111</span>, <span class="number">2</span>:[<span class="number">23</span>,<span class="number">1</span>,<span class="number">4</span>], <span class="string">'23'</span>:&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="string">'d'</span>:<span class="string">'sad'</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#file = open('pickle_example.pickle','wb')</span></span><br><span class="line"><span class="comment">#pickle.dump(a_dict, file)   #装载在file</span></span><br><span class="line"><span class="comment">#file.close()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'pickle_example.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    a_dict1 = pickle.load(file)</span><br><span class="line">print(a_dict1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#file = open('pickle_example.pickle','rb')</span></span><br><span class="line"><span class="comment">#a_dict1 = pickle.load(file)</span></span><br><span class="line"><span class="comment">#file.close()</span></span><br></pre></td></tr></table></figure>
<p>with语句可以用于打开open 此时不用file.close()也可以进行文件的读取。</p>
<p>13.set</p>
<p>1)</p>
<p>不能在set当中传列表与tuple两种形式会报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'Welcome Back to this Tutorial'</span></span><br><span class="line"></span><br><span class="line">print(type(set(char_list)))</span><br><span class="line">print(type(&#123;<span class="number">1</span>:<span class="number">2</span>&#125;))</span><br><span class="line">print(set(sentence))</span><br><span class="line">print(set([sentence, char_list]))  <span class="comment">#本句会报错</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">set</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line">&#123;'l', 'k', 'T', 'i', 'o', 'm', ' ', 'u', 'W', 'e', 'B', 't', 'r', 'c', 'h', 's', 'a'&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:/Users/36987/Desktop/pythontest/test3.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(set([sentence, char_list]))</span><br><span class="line">TypeError: unhashable type: <span class="string">'list'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'Welcome Back to this Tutorial'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(type(set(char_list)))</span></span><br><span class="line"><span class="comment">#print(type(&#123;1:2&#125;))</span></span><br><span class="line">print(set(sentence))</span><br><span class="line">unique_char = set(char_list)</span><br><span class="line">unique_char.add(<span class="string">'x'</span>)</span><br><span class="line">print(unique_char)</span><br><span class="line"></span><br><span class="line">unique_char.add(<span class="string">'a'</span>)</span><br><span class="line">print(unique_char)</span><br><span class="line"></span><br><span class="line">unique_char.add([<span class="string">'a'</span>,<span class="string">'b'</span>])  <span class="comment">#此句报错 因此说明一次只可以加1个字母</span></span><br><span class="line">print(unique_char)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'c'</span>, <span class="string">' '</span>, <span class="string">'h'</span>, <span class="string">'T'</span>, <span class="string">'l'</span>, <span class="string">'a'</span>, <span class="string">'W'</span>, <span class="string">'i'</span>, <span class="string">'t'</span>, <span class="string">'o'</span>, <span class="string">'e'</span>, <span class="string">'m'</span>, <span class="string">'s'</span>, <span class="string">'B'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>, <span class="string">'u'</span>&#125;</span><br><span class="line">&#123;<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'x'</span>&#125;</span><br><span class="line">&#123;<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'x'</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"C:/Users/36987/Desktop/pythontest/test3.py"</span>, line <span class="number">15</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    unique_char.add([<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line">TypeError: unhashable type: <span class="string">'list'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'Welcome Back to this Tutorial'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(set(sentence))</span><br><span class="line">unique_char = set(char_list)</span><br><span class="line">unique_char.add(<span class="string">'x'</span>)</span><br><span class="line">print(unique_char)</span><br><span class="line"></span><br><span class="line">unique_char.clear()</span><br><span class="line">print(unique_char)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;W&apos;, &apos;o&apos;, &apos;t&apos;, &apos;r&apos;, &apos;B&apos;, &apos;e&apos;, &apos;T&apos;, &apos; &apos;, &apos;u&apos;, &apos;c&apos;, &apos;m&apos;, &apos;i&apos;, &apos;h&apos;, &apos;k&apos;, &apos;a&apos;, &apos;l&apos;, &apos;s&apos;&#125;</span><br><span class="line">&#123;&apos;b&apos;, &apos;d&apos;, &apos;c&apos;, &apos;x&apos;, &apos;a&apos;&#125;</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>
<p>2)清除clear</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'Welcome Back to this Tutorial'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(set(sentence))</span><br><span class="line">unique_char = set(char_list)</span><br><span class="line">unique_char.add(<span class="string">'x'</span>)</span><br><span class="line">print(unique_char)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unique_char.clear()</span></span><br><span class="line"><span class="comment">#print(unique_char)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(unique_char.remove(<span class="string">'x'</span>))  <span class="comment">#返回值为NONE</span></span><br><span class="line">print(unique_char)  <span class="comment">#返回结果</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;m&apos;, &apos;s&apos;, &apos;i&apos;, &apos;c&apos;, &apos;a&apos;, &apos;T&apos;, &apos;l&apos;, &apos;o&apos;, &apos;e&apos;, &apos;u&apos;, &apos; &apos;, &apos;r&apos;, &apos;B&apos;, &apos;k&apos;, &apos;h&apos;, &apos;t&apos;, &apos;W&apos;&#125;</span><br><span class="line">&#123;&apos;c&apos;, &apos;d&apos;, &apos;a&apos;, &apos;x&apos;, &apos;b&apos;&#125;</span><br><span class="line">None</span><br><span class="line">&#123;&apos;c&apos;, &apos;d&apos;, &apos;a&apos;, &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>如果remove的东西不存在于数组中会报错</p>
<p>3)dicard</p>
<p>因此多了一个dicard 可以避免报错 会继续返回原有数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;h&apos;, &apos;u&apos;, &apos;m&apos;, &apos;k&apos;, &apos;o&apos;, &apos;W&apos;, &apos;c&apos;, &apos;r&apos;, &apos;i&apos;, &apos; &apos;, &apos;B&apos;, &apos;a&apos;, &apos;s&apos;, &apos;t&apos;, &apos;e&apos;, &apos;T&apos;, &apos;l&apos;&#125;</span><br><span class="line">&#123;&apos;b&apos;, &apos;d&apos;, &apos;c&apos;, &apos;x&apos;, &apos;a&apos;&#125;</span><br><span class="line">None</span><br><span class="line">&#123;&apos;b&apos;, &apos;d&apos;, &apos;c&apos;, &apos;x&apos;, &apos;a&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>4）set1.difference(set2) 可以输出set1中有set2中没有的东西</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'Welcome Back to this Tutorial'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unique_char = set(char_list)</span><br><span class="line">unique_char.add(<span class="string">'x'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set1 = unique_char</span><br><span class="line">set2 = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>&#125;</span><br><span class="line">print(set1)</span><br><span class="line">print(set2)</span><br><span class="line">print(set1.difference(set2))</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;x&apos;, &apos;d&apos;&#125;</span><br><span class="line">&#123;&apos;a&apos;, &apos;e&apos;, &apos;i&apos;&#125;</span><br><span class="line">&#123;&apos;b&apos;, &apos;x&apos;, &apos;c&apos;, &apos;d&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>5）相同的地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'Welcome Back to this Tutorial'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unique_char = set(char_list)</span><br><span class="line">unique_char.add(<span class="string">'x'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set1 = unique_char</span><br><span class="line">set2 = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>&#125;</span><br><span class="line">print(set1)</span><br><span class="line">print(set2)</span><br><span class="line">print(set1.intersection(set2))</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;x&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;, &apos;d&apos;&#125;</span><br><span class="line">&#123;&apos;e&apos;, &apos;i&apos;, &apos;a&apos;&#125;</span><br><span class="line">&#123;&apos;a&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>三、正则表达式</p>
<p>用于做爬虫</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Gao Lijie">
            
              <p class="site-author-name" itemprop="name">Gao Lijie</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">99</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/gaolijiemathcs" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="gaolijiemathcs@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gao Lijie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
